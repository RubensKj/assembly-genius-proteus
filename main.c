/* Main.c file generated by New Project wizard
 *
 * Created:   sex ago 13 2021
 * Processor: 8086
 * Compiler:  Digital Mars C
 *
 * Before starting simulation set Internal Memory Size 
 * in the 8086 model properties to 0x10000
 */
 

#define IO0  0000H
#define IO1  0200H
#define IO2  0400H
#define IO3  0600H
#define IO4  0800H
#define IO5  0A00H
#define IO6  0C00H
#define IO7  0E00H
#define IO8  1000H
#define IO9  1200H
#define IO10 1400H
#define IO11 1600H
#define IO12 1800H
#define IO13 1A00H

unsigned char DDH = 1;
unsigned char UUH = 3;
unsigned char DDM = 5;
unsigned char UUM = 9;
unsigned char DDS = 5;
unsigned char UUS = 9;

unsigned char dezena_hora = 0;
unsigned char unidade_hora = 0;
unsigned char dezena_minuto = 0;
unsigned char unidade_minuto = 0;
unsigned char dezena_segundo = 0;
unsigned char unidade_segundo = 0;

unsigned char SSS = 0;
unsigned char MMM = 0;
unsigned char HHH = 0;

unsigned char MMM_despertador = 0;
unsigned char HHH_despertador = 0;

unsigned char despertador_definido = 0;
unsigned char modo_despertador = 0;

unsigned int SEED = 0;
unsigned int SCORE = 0;
unsigned int RANDOM_NUMBER = 0;

unsigned int CURRENT_ANSWER = 0;

unsigned char RANDOM_TABLE[1024];
unsigned char ACERTOU_SEQUENCIA;
unsigned int Random_Table_Indice_Acertos;

unsigned char SPLASH[] = {
0x04, 0x04, 0xFF,0xFF,0xC3,0xC3,0xC3,0xC3,0xFF,0xFF,
0x00,0xFF,0xFF,0x83,0x83,0x83,0x03,0x03,
0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,
0x00,0xFF,0xFF,0x03,0x03,0x03,0xFF,0xFF,
0xFF,0xFF,0x07,0x0E,0x1C,0x38,0xF0,0xE0,
0x00,0xFF,0xFF,0xC1,0xC1,0xC1,0xC0,0xC0,
0x00,0xFF,0xFF,0xC0,0xC0,0xC0,0xC0,0xC0,
0x00,0xFF,0xFF,0xC0,0xC0,0xC0,0xFF,0xFF,
0xFE,0xFE,0x86,0x86,0x86,0x86,0x86,0x86,
0x00,0xFE,0xFE,0x06,0x06,0x06,0xFE,0xFE,
0x00,0xFE,0xFE,0x86,0x86,0x86,0x06,0x06,
0x00,0x06,0x06,0x06,0xFE,0xFE,0x06,0x06,
0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xFF,0xFF,
0x00,0xFF,0xFF,0xC0,0xC0,0xC0,0xFF,0xFF,
0x00,0xFF,0xFF,0x01,0x01,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00

};

unsigned char DESPERTADOR[] = {
0x02, 0x02,
0x00,0x00,0xC0,0xC0,0x30,0x30,0x30,0xB0,
0xC4,0xC4,0x08,0x1A,0x62,0x0C,0x01,0x00,
0x0F,0x0F,0x30,0x30,0xC0,0xC6,0xDE,0xC1,
0x30,0x30,0x0F,0x0F,0x00,0x00,0x00,0x00
};

unsigned char RELOGIO[] = {
0x02, 0x02,
0xF0,0xF0,0x0C,0x0C,0x03,0x03,0x83,0xC3,
0xC3,0xA3,0x1B,0x03,0x0C,0x0C,0xF0,0xF0,
0x0F,0x0F,0x30,0x30,0xC0,0xC0,0xC1,0xC3,
0xDF,0xC1,0xC0,0xC0,0x30,0x30,0x0F,0x0F
};

unsigned char LIMPO[] = { 0x10, 0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };

unsigned char ESQUERDA_BAIXO[]= { 
   0x04, 0x04,
   0x1C,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,
   0xFC,0xFC,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x01,0x0F,0x3F,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x03,0x07,0x0F,
   0x1F,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x01,0x03,0x07,0x07,
   0x0F,0x0F,0x1F,0x1F,0x3F,0x3F,0x3F,0x7F,
   0x7F,0x7F,0x7F,0xFF,0xFF,0xFF,0x00,0x00
};

unsigned char ESQUERDA_CIMA[] = {
   0x04, 0x04,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xE0,
   0xF0,0xF0,0xF8,0xF8,0xFC,0xFC,0xFC,0xFE,
   0xFE,0xFE,0xFE,0xFF,0xFF,0xFF,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0xC0,0xE0,0xF0,
   0xF8,0xFE,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
   0xFF,0x7F,0x3F,0x1F,0x0F,0x07,0x00,0x00,
   0x00,0x80,0xF0,0xFC,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
   0xFF,0x7F,0x3F,0x1F,0x0F,0x07,0x03,0x01,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x38,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
   0x3F,0x3F,0x3F,0x1F,0x0F,0x07,0x03,0x01,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

unsigned char DIREITA_BAIXO[] = {
   0x04, 0x04,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFC,0xFC,
   0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0x1C,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0x3F,0x0F,0x01,0x00,
   0x00,0x00,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x7F,0x1F,
   0x0F,0x07,0x03,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0xFF,0xFF,0xFF,0x7F,0x7F,0x7F,
   0x7F,0x3F,0x3F,0x3F,0x1F,0x1F,0x0F,0x0F,
   0x07,0x07,0x03,0x01,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

unsigned char DIREITA_CIMA[] = {
   0x04, 0x04,   
   0x00,0x00,0xFF,0xFF,0xFF,0xFE,0xFE,0xFE,
   0xFE,0xFC,0xFC,0xFC,0xF8,0xF8,0xF0,0xF0,
   0xE0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x07,0x0F,0x1F,0x3F,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFE,0xF8,
   0xF0,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFC,0xF0,0x80,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x01,0x03,0x07,0x0F,0x1F,0x3F,0x3F,0x3F,
   0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x38
};

unsigned char PLAY[] = {
   0x08, 0x08,   
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
   0x80,0x80,0x00,0x00,0x00,0x00,0x80,0x80,
   0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x80,
   0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x80,
   0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,
   0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
   0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0xFE,0xFE,0x61,
   0x61,0x61,0xFE,0xFE,0x00,0x00,0xFF,0xFF,
   0x19,0x19,0x19,0x1F,0x1F,0x00,0x00,0xFF,
   0xFF,0x99,0x99,0x81,0x81,0x00,0x00,0xFF,
   0xFF,0x79,0xF9,0xD9,0x9F,0x9F,0x00,0x00,
   0x01,0x01,0x01,0xFF,0xFF,0x01,0x01,0x01,
   0x00,0x00,0xFF,0xFF,0x99,0x99,0x81,0x81,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,
   0x00,0x00,0x01,0x01,0x00,0x00,0x01,0x01,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
   0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x01,
   0x01,0x00,0x00,0x01,0x01,0x01,0x00,0x00,
   0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,
   0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
   0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0xFC,0xFC,0x0C,0x0C,0xCC,
   0xCC,0xCC,0xCC,0xCC,0xCC,0x0C,0x0C,0xCC,
   0xCC,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
   0x0C,0xCC,0xCC,0xCC,0x0C,0x0C,0x0C,0x0C,
   0xCC,0xCC,0x0C,0x0C,0xCC,0xCC,0x0C,0x0C,
   0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x7F,
   0x7F,0x0C,0x0C,0x0F,0x0F,0x00,0x00,0x7F,
   0x7F,0x60,0x60,0x60,0x60,0x00,0x00,0x7F,
   0x7F,0x18,0x18,0x18,0x7F,0x7F,0x00,0x00,
   0x03,0x03,0x7C,0x7C,0x03,0x03,0x00,0x00,
   0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x07,0x07,0x06,0x06,0x06,
   0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
   0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
   0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
   0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
   0x07,0x07,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

unsigned char ERRO_ICON[] = {
   0x08, 0x08,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,
   0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,
   0xC0,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,
   0xC0,0xC0,0x00,0x00,0xC0,0xC0,0xC0,0xC0,
   0xC0,0xC0,0xC0,0x00,0x00,0xC0,0xC0,0x00,
   0x00,0x00,0xC0,0xC0,0x00,0x00,0xC0,0xC0,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0xFF,0xFF,0xCC,0xCC,0xC0,0xC0,0xC0,
   0x00,0x00,0xFF,0xFF,0x3C,0x7C,0xEC,0xCF,
   0xCF,0x00,0x00,0xFF,0xFF,0x3C,0x7C,0xEC,
   0xCF,0xCF,0x00,0x00,0xFF,0xFF,0xC0,0xC0,
   0xC0,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xC0,
   0xC0,0xC0,0xFF,0xFF,0x00,0x00,0xDF,0xDF,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x03,0x07,0x0E,0x1C,
   0x38,0x70,0xE0,0xC0,0x80,0x00,0x00,0x00,
   0x00,0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,
   0x1C,0x0E,0x07,0x03,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x81,0xC3,0xE7,0x7E,0x3C,
   0x3C,0x7E,0xE7,0xC3,0x81,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0xC0,0xE0,0x70,0x38,
   0x1C,0x0E,0x07,0x03,0x01,0x00,0x00,0x00,
   0x00,0x00,0x00,0x01,0x03,0x07,0x0E,0x1C,
   0x38,0x70,0xE0,0xC0,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

unsigned char AGUARDANDO_RESPOSTA[] = {
   0x0A, 0x04,
   0xF0,0xF0,0x8C,0x8C,0xF0,0xF0,0x00,0x00,
   0xFC,0xFC,0x0C,0xCC,0xCC,0xCC,0x00,0x00,
   0xFC,0xFC,0x00,0x00,0x00,0xFC,0xFC,0x00,
   0x00,0xF0,0xF0,0x8C,0x8C,0xF0,0xF0,0x00,
   0x00,0xFC,0xFC,0xCC,0xCC,0xFC,0xFC,0x00,
   0x00,0xFC,0xFC,0x0C,0x0C,0x1C,0xFC,0x00,
   0xF0,0xF0,0x8C,0x8C,0xF0,0xF0,0x00,0x00,
   0xFC,0xFC,0x0C,0x30,0xC0,0xFC,0xFC,0x00,
   0x00,0xFC,0xFC,0x0C,0x0C,0x1C,0xFC,0x00,
   0x00,0xFC,0xFC,0x0C,0x0C,0xFC,0xFC,0x00,
   0x07,0x07,0x01,0x01,0x07,0x07,0x00,0x00,
   0x07,0xC7,0xC6,0xC6,0xC6,0xC7,0xC0,0x00,
   0x07,0xC7,0xC6,0xC6,0xC6,0xC7,0xC7,0x00,
   0x00,0xC7,0xC7,0xC1,0xC1,0xC7,0x07,0x00,
   0xC0,0xC7,0xC7,0xC3,0xC7,0xC6,0x06,0x00,
   0xC0,0xC7,0xC7,0xC6,0xC6,0xC7,0x07,0x00,
   0xC7,0xC7,0xC1,0xC1,0xC7,0x07,0x00,0x00,
   0xC7,0xC7,0xC0,0xC0,0xC0,0xC7,0x07,0x00,
   0x00,0x07,0xC7,0xC6,0x06,0x07,0x07,0x00,
   0x00,0x07,0x07,0x06,0x06,0x07,0x07,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x7F,0x7F,0x3C,0x7C,0x6F,0x6F,0x00,
   0x00,0x7F,0x7F,0x6C,0x6C,0x60,0x60,0x00,
   0x00,0x67,0x67,0x64,0x7C,0x7C,0x00,0x00,
   0x7F,0x7F,0x0C,0x0C,0x0F,0x0F,0x00,0x00,
   0x7F,0x7F,0x60,0x60,0x7F,0x7F,0x00,0x00,
   0x67,0x67,0x64,0x7C,0x7C,0x00,0x00,0x00,
   0x00,0x00,0x7F,0x7F,0x00,0x00,0x00,0x00,
   0x7F,0x7F,0x18,0x18,0x7F,0x7F,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,
   0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,
   0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

// 8251A USART 

#define ADR_USART_DATA   (IO9 + 00h)
//ONDE VOCE VAI MANDAR E RECEBER DADOS DO 8251

#define ADR_USART_CMD   (IO9 + 02h)
//É O LOCAL ONDE VOCE VAI ESCREVER PARA PROGRAMAR O 8251
//WRITE 1202H

#define ADR_USART_STAT  (IO9 + 02h)
//RETORNA O STATUS SE UM CARACTER FOI DIGITADO NO TERMINAL
//RETORNA O STATUS SE POSSO TRANSMITIR CARACTER PARA O TERMINAL
//READ 1202H 

//ENDEREÇOS DOS REGISTRADORES DO 8255
#define ADR_PPI_PORTA	  (IO10)
#define ADR_PPI_PORTB	  (IO10 + 02h)
#define ADR_PPI_PORTC	  (IO10 + 04h)
#define ADR_PPI_CONTROL	  (IO10 + 06h)

//ENDEREÇOS DOS REGISTRADORES DO 8255 PARA CONTROLAR DISPLAY GRAFICO
#define ADR_PPI_PORTA_LCD	  (IO11)
#define ADR_PPI_PORTB_LCD	  (IO11 + 02h)
#define ADR_PPI_PORTC_LCD	  (IO11 + 04h)
#define ADR_PPI_CONTROL_LCD	  (IO11 + 06h)

#define PPI_PORTA_INP	  10h //00010000
#define PPI_PORTA_OUT	  00h
#define PPI_PORTB_INP	  02h
#define PPI_PORTB_OUT	  00h
#define PPI_PORTCL_INP	  01h //00000001
#define PPI_PORTCL_OUT	  00h
#define PPI_PORTCH_INP	  08h
#define PPI_PORTCH_OUT	  00h
#define PPI_MODE_BCL_0	  00h
#define PPI_MODE_BCL_1	  04h
#define PPI_MODE_ACH_0	  00h
#define PPI_MODE_ACH_1	  20h  //00100000
#define PPI_MODE_ACH_2	  40h  //01000000
#define PPI_ACTIVE	  80h  //10000000

//O 8253 É UM CHIP DA INTEL QUE CONSEGUE PEGAR UMA FREQUENCIA DE ENTRADA E DIVIDE
//POR UM VALOR DE 16 BITS O QUAL PRODUZ UMA UMA FREQUENCIA MENOR
//ESTAS FREQUENCIA MENOR PODE SER UM "DÓ" POR EXEMPLO
//A FREQUENCIA DE ENTRADA É DE 100Khz
//SE QUISERMOS POR EXEMPLO PRODUZIR UM DÓ (523.25HZ), TEMOS QUE DIVIDIR 100.000HZ POR X PARA
//PRODUZIR 523.25HZ, OU SEJA, X = 0BFH
//PARA USO DO 8253, VOCE DEVE MAPEAR IO CONFORME ABAIXO (VEJA QUAL ESTA LIVRE EM SEU PROJETO)

#define ADR_TIMER_DATA0     (IO12 + 00h)
#define ADR_TIMER_DATA1     (IO12 + 02h)
#define ADR_TIMER_DATA2     (IO12 + 04h)
#define ADR_TIMER_CONTROL   (IO12 + 06h)

#define TIMER_COUNTER0	 00h
#define TIMER_COUNTER1	 40h
#define TIMER_COUNTER2	 80h

#define TIMER_LATCH	00h
#define TIMER_LSB	10h
#define TIMER_MSB	20h
#define TIMER_LSB_MSB 	30h

#define TIMER_MODE0	00h
#define TIMER_MODE1	02h
#define TIMER_MODE2	04h
#define TIMER_MODE3	06h
#define TIMER_MODE4	08h
#define TIMER_MODE5	09h
#define TIMER_BCD	01h

#define true  1
#define false 0

#define NULL 0

#define TAM 99
#define TAM_NUMERO 2

char STRING[TAM+1];
unsigned char QNT_CARACTERES_DIGITADOS;

void RECEBER_CARACTER(void);
void MANDA_CARACTER(void);
void LIMPA_TELA_LCD(void);
void ALTERANDO_DESPERTADOR(void);
void INICIALIZA_8253_TIMER0(void);
void RESETA_VARIAVEIS_HORAS(void);
void FAZ_BEEP(void);
void EXECUTAR_TENTATIVA_JOGO(void);

#define NULL 0

char STRING1[TAM+1];
char STRING2[TAM+1];

char MENS1[] = {"ENTRE COM UM NUMERO"};
char MENS2[] = {" * "};
char MENS3[] = {" = "};

unsigned char TECLA;

//VARIAVEIS AUXILIARES
unsigned char GLCD_CONTROL = 0;
unsigned char GLCD_DATA    = 0;
unsigned char COL_DATA = 0;
unsigned char COL_DATA_AUX = 0;
unsigned char READ_DATA = 0;
unsigned char LINHA = 0;

unsigned char QNT_COLUNAS = 0;
unsigned char SALVA_QNT_COLUNAS = 0;
unsigned char POS_COLUNAS = 0;

unsigned char DOG[] = {
2,2,0x00,0x00,0x18,0x08,0x2C,0x2C,0xC8,0x40,
0xC0,0x08,0x28,0x2C,0x04,0x0C,0x00,0x00,
0x00,0x00,0x00,0x06,0x0C,0x18,0x11,0x71,
0xD1,0xF0,0x10,0x18,0x0E,0x00,0x00,0x00
};

unsigned char SHIP[] = {0x03,0x03,0x00,0x00,0x00,0x30,0x78,0x78,0x30,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xFC,0xFC,0xF8,0xF8,0x70,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x60,0xE0,0xE0,0xFF,0xE1,0xE1,0xE0,0xE0,0xE0,
0x60,0x20,0x00,0x00,0x00,0x00,0x00,0x00};

unsigned char FONTS[128][5] =
{
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x5F, 0x00, 0x00},
    {0x00, 0x07, 0x00, 0x07, 0x00},
    {0x14, 0x7F, 0x14, 0x7F, 0x14},
    {0x24, 0x2A, 0x7F, 0x2A, 0x12},
    {0x23, 0x13, 0x08, 0x64, 0x62},
    {0x36, 0x49, 0x55, 0x22, 0x50},
    {0x00, 0x05, 0x03, 0x00, 0x00},
    {0x00, 0x1C, 0x22, 0x41, 0x00},
    {0x00, 0x41, 0x22, 0x1C, 0x00},
    {0x08, 0x2A, 0x1C, 0x2A, 0x08},
    {0x08, 0x08, 0x3E, 0x08, 0x08},
    {0x00, 0x50, 0x30, 0x00, 0x00},
    {0x08, 0x08, 0x08, 0x08, 0x08},
    {0x00, 0x60, 0x60, 0x00, 0x00},
    {0x20, 0x10, 0x08, 0x04, 0x02},
    {0x3E, 0x51, 0x49, 0x45, 0x3E},
    {0x00, 0x42, 0x7F, 0x40, 0x00},
    {0x42, 0x61, 0x51, 0x49, 0x46},
    {0x21, 0x41, 0x45, 0x4B, 0x31},
    {0x18, 0x14, 0x12, 0x7F, 0x10},
    {0x27, 0x45, 0x45, 0x45, 0x39},
    {0x3C, 0x4A, 0x49, 0x49, 0x30},
    {0x01, 0x71, 0x09, 0x05, 0x03},
    {0x36, 0x49, 0x49, 0x49, 0x36},
    {0x06, 0x49, 0x49, 0x29, 0x1E},
    {0x00, 0x36, 0x36, 0x00, 0x00},
    {0x00, 0x56, 0x36, 0x00, 0x00},
    {0x00, 0x08, 0x14, 0x22, 0x41},
    {0x14, 0x14, 0x14, 0x14, 0x14},
    {0x41, 0x22, 0x14, 0x08, 0x00},
    {0x02, 0x01, 0x51, 0x09, 0x06},
    {0x32, 0x49, 0x79, 0x41, 0x3E},
    {0x7E, 0x11, 0x11, 0x11, 0x7E},
    {0x7F, 0x49, 0x49, 0x49, 0x36},
    {0x3E, 0x41, 0x41, 0x41, 0x22},
    {0x7F, 0x41, 0x41, 0x22, 0x1C},
    {0x7F, 0x49, 0x49, 0x49, 0x41},
    {0x7F, 0x09, 0x09, 0x01, 0x01},
    {0x3E, 0x41, 0x41, 0x51, 0x32},
    {0x7F, 0x08, 0x08, 0x08, 0x7F},
    {0x00, 0x41, 0x7F, 0x41, 0x00},
    {0x20, 0x40, 0x41, 0x3F, 0x01},
    {0x7F, 0x08, 0x14, 0x22, 0x41},
    {0x7F, 0x40, 0x40, 0x40, 0x40},
    {0x7F, 0x02, 0x04, 0x02, 0x7F},
    {0x7F, 0x04, 0x08, 0x10, 0x7F},
    {0x3E, 0x41, 0x41, 0x41, 0x3E},
    {0x7F, 0x09, 0x09, 0x09, 0x06},
    {0x3E, 0x41, 0x51, 0x21, 0x5E},
    {0x7F, 0x09, 0x19, 0x29, 0x46},
    {0x46, 0x49, 0x49, 0x49, 0x31},
    {0x01, 0x01, 0x7F, 0x01, 0x01},
    {0x3F, 0x40, 0x40, 0x40, 0x3F},
    {0x1F, 0x20, 0x40, 0x20, 0x1F},
    {0x7F, 0x20, 0x18, 0x20, 0x7F},
    {0x63, 0x14, 0x08, 0x14, 0x63},
    {0x03, 0x04, 0x78, 0x04, 0x03},
    {0x61, 0x51, 0x49, 0x45, 0x43},
    {0x00, 0x00, 0x7F, 0x41, 0x41},
    {0x02, 0x04, 0x08, 0x10, 0x20},
    {0x41, 0x41, 0x7F, 0x00, 0x00},
    {0x04, 0x02, 0x01, 0x02, 0x04},
    {0x40, 0x40, 0x40, 0x40, 0x40},
    {0x00, 0x01, 0x02, 0x04, 0x00},
    {0x20, 0x54, 0x54, 0x54, 0x78},
    {0x7F, 0x48, 0x44, 0x44, 0x38},
    {0x38, 0x44, 0x44, 0x44, 0x20},
    {0x38, 0x44, 0x44, 0x48, 0x7F},
    {0x38, 0x54, 0x54, 0x54, 0x18},
    {0x08, 0x7E, 0x09, 0x01, 0x02},
    {0x08, 0x14, 0x54, 0x54, 0x3C},
    {0x7F, 0x08, 0x04, 0x04, 0x78},
    {0x00, 0x44, 0x7D, 0x40, 0x00},
    {0x20, 0x40, 0x44, 0x3D, 0x00},
    {0x00, 0x7F, 0x10, 0x28, 0x44},
    {0x00, 0x41, 0x7F, 0x40, 0x00},
    {0x7C, 0x04, 0x18, 0x04, 0x78},
    {0x7C, 0x08, 0x04, 0x04, 0x78},
    {0x38, 0x44, 0x44, 0x44, 0x38},
    {0x7C, 0x14, 0x14, 0x14, 0x08},
    {0x08, 0x14, 0x14, 0x18, 0x7C},
    {0x7C, 0x08, 0x04, 0x04, 0x08},
    {0x48, 0x54, 0x54, 0x54, 0x20},
    {0x04, 0x3F, 0x44, 0x40, 0x20},
    {0x3C, 0x40, 0x40, 0x20, 0x7C},
    {0x1C, 0x20, 0x40, 0x20, 0x1C},
    {0x3C, 0x40, 0x30, 0x40, 0x3C},
    {0x44, 0x28, 0x10, 0x28, 0x44},
    {0x0C, 0x50, 0x50, 0x50, 0x3C},
    {0x44, 0x64, 0x54, 0x4C, 0x44},
    {0x00, 0x08, 0x36, 0x41, 0x00},
    {0x00, 0x00, 0x7F, 0x00, 0x00},
    {0x00, 0x41, 0x36, 0x08, 0x00},
    {0x08, 0x08, 0x2A, 0x1C, 0x08},
    {0x08, 0x1C, 0x2A, 0x08, 0x08}
};

//---------------------------------------------------------
//ROTINAS PARA 8255 DISPLAY GRAFICO  
void INICIALIZA_8255_LCD(void)
{
   _asm {
   PUSHF
   PUSH AX
   PUSH DX
   MOV DX, ADR_PPI_CONTROL_LCD
   MOV AL,0
   OR AL,PPI_PORTA_OUT
   OR AL,PPI_PORTB_OUT  
   OR AL,PPI_PORTCL_INP
   OR AL,PPI_PORTCH_INP
   OR AL,PPI_MODE_BCL_0
   OR AL,PPI_MODE_ACH_0
   OR AL,PPI_ACTIVE
   OUT DX,AL
   POP DX
   POP AX
   POPF
   }
}

void INICIALIZA_8255_PORT_INPUT_LCD(void)
{
   _asm {
   PUSHF
   PUSH AX
   PUSH DX
   MOV DX, ADR_PPI_CONTROL_LCD
   MOV AL,0
   OR AL,PPI_PORTA_OUT
   OR AL,PPI_PORTB_INP
   OR AL,PPI_PORTCL_INP
   OR AL,PPI_PORTCH_INP
   OR AL,PPI_MODE_BCL_0
   OR AL,PPI_MODE_ACH_0
   OR AL,PPI_ACTIVE
   OUT DX,AL
   POP DX
   POP AX
   POPF
   }
}

void MANDA_PORT_A_LCD(void)
{
   _asm {
    PUSHF
    PUSH DX
    MOV DX,ADR_PPI_PORTA_LCD
    OUT DX,AL
    POP DX
    POPF
   }
}

void MANDA_PORT_B_LCD(void)
{
   _asm {
    PUSHF
    PUSH DX
    MOV DX,ADR_PPI_PORTB_LCD
    OUT DX,AL
    POP DX
    POPF
   }
}

void LE_PORT_B_LCD(void)
{
   _asm {
    PUSHF
    PUSH DX
    MOV DX,ADR_PPI_PORTB_LCD
    IN AL,DX
    POP DX
    POPF
    }
}

void LE_PORT_C_LCD(void)
{
    _asm {
    PUSHF
    PUSH DX
    MOV DX,ADR_PPI_PORTC_LCD
    IN AL,DX
    POP DX
    POPF
    }
}

//---------------------------------------------------------
//ESTAS ROTINAS TEM CONTROLE INDIVIDUAIS DOS SINAIS QUE CHEGAM AO DISPLAY GRAFICO
void GLCD_CS1_HIGH(void)
{
   _asm {      
   PUSHF
   PUSH AX
   OR  GLCD_CONTROL, 32
   MOV AL,GLCD_CONTROL
   CALL MANDA_PORT_A_LCD
   POP AX
   POPF
   }
}

void GLCD_CS1_LOW(void)
{
   _asm {
   PUSHF
   PUSH AX
   MOV AL, 32
   NOT AL
   AND  GLCD_CONTROL, AL
   MOV AL,GLCD_CONTROL
   CALL MANDA_PORT_A_LCD
   POP AX
   POPF
   }
}

void GLCD_CS2_HIGH(void)
{
   _asm {
   PUSHF
   PUSH AX
   OR  GLCD_CONTROL, 16
   MOV AL,GLCD_CONTROL
   CALL MANDA_PORT_A_LCD
   POP AX
   POPF
   }
}

void GLCD_CS2_LOW(void)
{
   _asm {
   PUSHF
   PUSH AX
   MOV AL, 16
   NOT AL
   AND  GLCD_CONTROL, AL
   MOV AL,GLCD_CONTROL
   CALL MANDA_PORT_A_LCD
   POP AX
   POPF
   }
}

void GLCD_RST_HIGH(void)
{
   _asm {
   PUSHF
   PUSH AX
   OR  GLCD_CONTROL, 1
   MOV AL,GLCD_CONTROL
   CALL MANDA_PORT_A_LCD
   POP AX
   POPF
   }
}

void GLCD_RST_LOW(void)
{
   _asm {      
   PUSHF
   PUSH AX
   MOV AL, 1
   NOT AL
   AND  GLCD_CONTROL, AL
   MOV AL,GLCD_CONTROL
   CALL MANDA_PORT_A_LCD
   POP AX
   POPF
   }
}

void GLCD_EN_HIGH(void)
{
   _asm {
   PUSHF
   PUSH AX
   OR  GLCD_CONTROL, 2
   MOV AL,GLCD_CONTROL
   CALL MANDA_PORT_A_LCD
   POP AX
   POPF
   }
}

void GLCD_EN_LOW(void)
{
   _asm {
   PUSHF
   PUSH AX
   MOV AL, 2
   NOT AL
   AND  GLCD_CONTROL, AL
   MOV AL,GLCD_CONTROL
   CALL MANDA_PORT_A_LCD
   POP AX
   POPF
   }
}

void GLCD_RW_HIGH(void)
{
   _asm {
   PUSHF
   PUSH AX
   OR  GLCD_CONTROL, 4
   MOV AL,GLCD_CONTROL
   CALL MANDA_PORT_A_LCD
   POP AX
   POPF
   }
}
   
void GLCD_RW_LOW(void)
{
   _asm {      
   PUSHF
   PUSH AX
   MOV AL, 4
   NOT AL
   AND  GLCD_CONTROL, AL
   MOV AL,GLCD_CONTROL
   CALL MANDA_PORT_A_LCD
   POP AX
   POPF
   }
}

void GLCD_RS_HIGH(void)
{
   _asm {
   PUSHF
   PUSH AX
   OR  GLCD_CONTROL, 8
   MOV AL,GLCD_CONTROL
   CALL MANDA_PORT_A_LCD
   POP AX
   POPF
   }
}

void GLCD_RS_LOW(void)
{
   _asm {      
   PUSHF
   PUSH AX
   MOV AL, 8
   NOT AL
   AND  GLCD_CONTROL, AL
   MOV AL,GLCD_CONTROL
   CALL MANDA_PORT_A_LCD
   POP AX
   POPF
   }
}
   
void ENABLE_PULSE(void)
{
   _asm {
   CALL GLCD_EN_HIGH
   CALL GLCD_EN_LOW
   }
}

//LIGA DISPLAY
void GLCD_ON(void)
{
   _asm {      
   CALL GLCD_CS1_LOW
   CALL GLCD_CS2_LOW
   CALL GLCD_RS_LOW
   CALL GLCD_RW_LOW
   MOV AL,03FH
   CALL MANDA_PORT_B_LCD
   CALL ENABLE_PULSE
   }
}
   
//---------------------------------------------------------
//ATIVA O GLCD
void GLCD_ATIVA(void)
{
      _asm {
	CALL GLCD_CS1_HIGH
	CALL GLCD_CS2_HIGH
	CALL GLCD_RST_HIGH
	CALL GLCD_ON
      }
}
//---------------------------------------------------------


//------------------------------------
//POSICIONA "CURSOR" NA COLUNA
void GLCD_GOTO_COL(void)
{
   _asm {
   PUSHF
   PUSH AX

   CALL GLCD_RS_LOW
   CALL GLCD_RW_LOW
   CMP AH,64
   JL LEFT
   
   CALL GLCD_CS2_LOW
   CALL GLCD_CS1_HIGH
   SUB AH,64
   MOV COL_DATA,AH
   JMP SAI_GOTO_COL
   
LEFT:
    CALL GLCD_CS1_LOW
    CALL GLCD_CS2_HIGH
    MOV COL_DATA,AH

SAI_GOTO_COL:
   OR COL_DATA, 40H
   AND COL_DATA, 7FH
   MOV AL,COL_DATA
   CALL MANDA_PORT_B_LCD
   CALL ENABLE_PULSE
   POP AX
   POPF
   }
}
//------------------------------------

//------------------------------------
//POSICIONA "CURSOR" NA LINHA
void GLCD_GOTO_ROW(void)
{
   _asm {   
   PUSH AX
   CALL GLCD_RS_LOW
   CALL GLCD_RW_LOW
   OR AL,0B8H
   AND AL,0BFH
   MOV COL_DATA,AL
   CALL MANDA_PORT_B_LCD
   CALL ENABLE_PULSE
   POP AX
   }
}   
//------------------------------------


//------------------------------------   
// AH LINHA E  AL COLUNA
// POSICIONAMENTO DO "CURSOR" EM LINHA X COLUNA
// MODO GRAFICO (128x64)
void GLCD_GOTO_XY(void)
{
   _asm {
   CALL GLCD_GOTO_COL
   CALL GLCD_GOTO_ROW
   }
}
//------------------------------------   

// AL = DATA
void GLCD_WRITE(void)
{
   _asm {      
   CALL GLCD_RS_HIGH
   CALL GLCD_RW_LOW
   CALL MANDA_PORT_B_LCD
   CALL ENABLE_PULSE
   }
}
   
//AL = DATA  
void GLCD_CLRLN(void)
{
   _asm {
   PUSHF
   PUSH AX
   PUSH CX
   MOV AH,0
   CALL GLCD_GOTO_XY
   MOV AH,64
   CALL GLCD_GOTO_XY
   CALL GLCD_CS1_LOW
   MOV AL,0
   MOV CX,64
ESCREVA:   
   CALL GLCD_WRITE
   LOOP ESCREVA
   POP CX
   POP AX
   POPF
   }
}

//---------------------------------------------------------
//APAGA DISPLAY GRAFICO
void GLCD_CLR(void)
{
   _asm {
   PUSHF
   PUSH AX
   MOV AL,0
CLRLN:   
   CALL GLCD_CLRLN
   ADD AL,1
   CMP AL,8
   JNE CLRLN
   POP AX
   POPF
   }
}
//---------------------------------------------------------

//---------------------------------------------------------
//LE STATUS DO DISPLAY
void GLCD_READ_DATA(void)
{
    _asm {
    CALL INICIALIZA_8255_PORT_INPUT_LCD
    CALL GLCD_RW_HIGH
    CALL GLCD_RS_HIGH
    CMP AH,63
    JG  HAB_CS2

HAB_CS1:
    CALL GLCD_CS2_HIGH
    CALL GLCD_CS1_LOW
    JMP HAB

HAB_CS2:
    CALL GLCD_CS2_LOW
    CALL GLCD_CS1_HIGH

HAB:
     CALL GLCD_EN_HIGH
     CALL GLCD_EN_LOW
     CALL GLCD_EN_HIGH
     CALL LE_PORT_B_LCD
     MOV READ_DATA,AL
     CALL GLCD_EN_LOW
     CALL INICIALIZA_8255_LCD
  }
}
//---------------------------------------------------------

//---------------------------------------------------------
//DESENHA UM PONTO NESTAS COORDENADAS
//AH, AL, BH
//COLUNAS MODO GRAFICO = 128 (0..127) AH
//LINHAS MODO GRAFICO = 64 (0..63) AL
//BH = 0 PIXEL APAGADO, BH=1 PIXEL ACESO
void GLCD_DRAW_POINT(void)
{
    _asm {
    PUSHF
    PUSH AX
    PUSH BX
    PUSH CX

    PUSH AX ; SALVA AH, AL
    PUSH AX ; SALVA AH, AL
    
    MOV CH,AH ; SALVA AH
    MOV AH,0

    MOV BL,8
    DIV BL
    
    MOV AH,CH
    CALL GLCD_GOTO_XY
    
    POP AX  ; RESTAURA AH, AL
    
    CMP BH,0
    JE LIGHT_SPOT
    
    MOV AH,0
    MOV BH,8
    DIV BH
    ; AH RESTO
    MOV CL,AH
    MOV AL,1
    SHL AL,CL
    MOV COL_DATA_AUX,AL
    
    MOV AH,CH
    CALL GLCD_READ_DATA
    OR COL_DATA_AUX,AL

    JMP SAI_GLCD_DRAW_POINT
    
LIGHT_SPOT:
    MOV AH,0
    MOV BH,8
    DIV BH
    ; AH RESTO
    MOV CL,AH
    MOV AL,1
    SHL AL,CL
    NOT AL
    MOV COL_DATA_AUX,AL

    MOV AH,CH
    CALL GLCD_READ_DATA
    AND COL_DATA_AUX,AL

SAI_GLCD_DRAW_POINT:
    POP AX

    MOV CH,AH ; SALVA AH
    MOV AH,0

    MOV BL,8
    DIV BL
    
    MOV AH,CH
    CALL GLCD_GOTO_XY
   
    MOV AL, COL_DATA_AUX
    CALL GLCD_WRITE
   
    POP CX
    POP BX
    POP AX
    POPF
    }
 }
//---------------------------------------------------------

//---------------------------------------------------------
// AL = INDICE CARACTER FONT (COMECA EM 0)
// IMPRIME CARACTER NA LINHA E COLUNA DEFINIDA
void PRINT_CAR(void)
{
   _asm {
	PUSHF
	PUSH AX
	PUSH BX
	PUSH CX
	MOV BL,5
	MUL BL
	MOV BX,AX
	MOV CX,5
PRINTING_CAR:
	MOV AL,FONTS[BX]
        CALL GLCD_WRITE
        INC BX
	LOOP PRINTING_CAR
	POP CX
	POP BX
	POP AX
	POPF
	}
}
 
//------------------------------------
//POSICIONA "CURSOR" NA COLUNA
void GLCD_GOTO_COL_TEXT(void)
{
   _asm {
   PUSHF
   PUSH AX
   PUSH BX

   PUSH AX
   MOV BL,8
   MOV AL,AH
   MUL BL
   MOV BL,AL
   POP AX
   MOV AH,BL
  
   CALL GLCD_RS_LOW
   CALL GLCD_RW_LOW
   CMP AH,64
   JL LEFT_TEXT
   
   CALL GLCD_CS2_LOW
   CALL GLCD_CS1_HIGH
   SUB AH,64
   MOV COL_DATA,AH
   JMP SAI_GOTO_COL_TEXT
   
LEFT_TEXT:
    CALL GLCD_CS1_LOW
    CALL GLCD_CS2_HIGH
    MOV COL_DATA,AH

SAI_GOTO_COL_TEXT:
   OR COL_DATA, 40H
   AND COL_DATA, 7FH
   MOV AL,COL_DATA
   CALL MANDA_PORT_B_LCD
   CALL ENABLE_PULSE
   POP BX
   POP AX
   POPF
   }
}
//------------------------------------
   
//------------------------------------
//POSICIONA "CURSOR" NA LINHA
void GLCD_GOTO_ROW_TEXT(void)
{
   _asm {
   PUSH AX
   CALL GLCD_RS_LOW
   CALL GLCD_RW_LOW
   OR AL,0B8H
   AND AL,0BFH
   MOV COL_DATA,AL
   CALL MANDA_PORT_B_LCD
   CALL ENABLE_PULSE
   POP AX
   }
}
//------------------------------------

//------------------------------------   
// AH LINHA E  AL COLUNA
// POSICIONAMENTO DO "CURSOR" EM LINHA X COLUNA
// COLUNAS 16 (0..15), LINHAS 8 (0..7)
void GLCD_GOTO_XY_TEXT(void)
{
   _asm {
   CALL GLCD_GOTO_COL_TEXT
   CALL GLCD_GOTO_ROW_TEXT
   }
}
//------------------------------------   
 
//---------------------------------------------------------
// AH = COLUNA, AL=LINHA
// SI APONTA PARA A TABELA DO ICONE 
// NAO ESQUECA DE COLOCAR NOS 2 PRIMEIROS BYTES DA TABELA O TAMANHO DO ICONE!!!!!!!
// EXEMPLO, IMAGEM DE 24X24 PIXELS = 3 LINHAS X 3 COLUNAS
void PRINT_ICON(void)
{
	_asm {
	PUSHF
	PUSH AX
	PUSH CX
	MOV CL,  DS:[SI]  
	MOV QNT_COLUNAS, CL ; QNT COLUNAS IMPRESSAS
	MOV SALVA_QNT_COLUNAS, CL ; GUARDA QNT PARA NOVO LACO QNT COLUNAS IMPRESSAS
	MOV POS_COLUNAS, AH ; COLUNA PASSADA COMO PARAMETRO
	MOV CL,  DS:[SI+1]
	MOV LINHA, CL ;LINHA
	ADD SI,2    ; APONTA PARA ICONE...
PRINT:
	MOV CX,8
	CALL GLCD_GOTO_XY_TEXT	
PRINTING_ICON:
        PUSH AX
	MOV AL,DS:[SI]
        CALL GLCD_WRITE
	POP  AX
        INC SI
	LOOP PRINTING_ICON
	INC AH
	DEC QNT_COLUNAS
	JNE PRINT	
	MOV AH,SALVA_QNT_COLUNAS
	MOV QNT_COLUNAS,AH
	MOV AH,POS_COLUNAS
	INC AL
	DEC LINHA
	JNE PRINT	
	POP CX
	POP AX
	POPF
	}
}	
//---------------------------------------------------------
// ROTINAS PARA 8255   
void INICIALIZA_8255(void)
{
   _asm {
   PUSHF
   PUSH AX
   PUSH DX
   MOV DX, ADR_PPI_CONTROL
   MOV AL,0
   OR AL,PPI_PORTA_OUT
   OR AL,PPI_PORTB_OUT  
   OR AL,PPI_PORTCL_INP        
   OR AL,PPI_PORTCH_INP
   OR AL,PPI_MODE_BCL_0
   OR AL,PPI_MODE_ACH_0
   OR AL,PPI_ACTIVE
   OUT DX,AL
   POP DX
   POP AX
   POPF
   }      
}

//esta rotina escreve em PORT A o valor do registrador AL
void MANDA_PORT_A(void)
{
   _asm
   {
    PUSHF
    PUSH DX
    MOV DX,ADR_PPI_PORTA
    OUT DX,AL
    POP DX
    POPF
   }
}

//esta rotina escreve em PORT B o valor do registrador AL
void MANDA_PORT_B(void)
{
   _asm
   {
    PUSHF
    PUSH DX
    MOV DX,ADR_PPI_PORTB
    OUT DX,AL
    POP DX
    POPF
   }
}

//esta funcao retorna em AL o conteudo lido da entrada PORT C
void LE_PORT_C(void)
{
   _asm {
    PUSHF
    PUSH DX
    MOV DX,ADR_PPI_PORTC
    IN AL,DX
    POP DX
    POPF
   }
}

//certifique que BX esteja apontando para var STRING
void MAIUSCULO_STRING(void)
{
   _asm {
	 pushf 
	 push ax
      MAIUSCULO_STRING_PROCURA_NULL:
	 mov al, [bx]
	 cmp al, NULL
	 je MAISCULO_STRING_SAI
	 cmp al,'a'
	 jl MAISCULO_STRING_IGNORA       
	 cmp al,'z'
	 jg MAISCULO_STRING_IGNORA
	 sub al,32 //aqui há a transformacao de MINUSCULO para MAIUSCULO
	 mov [bx],al //atualiza memoria
	 inc bx //avanca na memoria
	 jmp MAIUSCULO_STRING_PROCURA_NULL
MAISCULO_STRING_IGNORA:
	 inc bx //avanca na memoria
	 jmp MAIUSCULO_STRING_PROCURA_NULL
MAISCULO_STRING_SAI:      
	 pop ax
	 popf
   }
}

//certifique que BX esteja apontando para var STRING
void MINUSCULO_STRING(void)
{
   _asm {
	 pushf 
	 push ax
      MINUSCULO_STRING_PROCURA_NULL:
	 mov al, [bx]
	 cmp al, NULL
	 je MINUSCULO_STRING_SAI
	 cmp al,'A'
	 jl MINUSCULO_STRING_IGNORA       
	 cmp al,'Z'
	 jg MINUSCULO_STRING_IGNORA
	 add al,32 //aqui há a transformacao de MAIUSCULO para MINUSCULO
	 mov [bx],al //atualiza memoria
	 inc bx //avanca na memoria
	 jmp MINUSCULO_STRING_PROCURA_NULL
MINUSCULO_STRING_IGNORA:
	 inc bx //avanca na memoria
	 jmp MINUSCULO_STRING_PROCURA_NULL
MINUSCULO_STRING_SAI:      
	 pop ax
	 popf
   }
}

//certifique que bx aponta para STRING
//al deve retornar o tamanho da STRING
void TAMANHO_STRING(void)
{
   _asm {
	 pushf
	 push cx
	 mov cl,0 //contador de caracteres
TAMANHO_STRING_PROCURA_NULL:      
	 mov al, [bx]
	 cmp al, NULL
	 je TAMANHO_STRING_SAI
	 inc cl //contando caracteres
	 inc bx //avanca BX na memoria
	 jmp TAMANHO_STRING_PROCURA_NULL	 
TAMANHO_STRING_SAI:
	 mov al,cl      
	 pop cx
	 popf
   }
}

//certifique que 
//si aponte para STRING1
//di aposte para STRING2
//al retorna 1 se forem iguais, 0 se forem diferentes
void COMPARA_STRING(void)
{
   _asm {
	 pushf
	 push dx
COMPARA_STRING_CONTINUA_COMPARACAO:      
	 mov dl, [si]
	 mov dh, [di]
	 cmp dl, NULL
	 je  COMPARA_STRING_STRING1_FINAL   
	 cmp dh, NULL
	 je  COMPARA_STRING_STRING2_FINAL
	 cmp dl,dh
	 je  COMPARA_STRING_CARACTER_IGUAL
	 mov al, false
	 jmp COMPARA_STRING_SAI
COMPARA_STRING_CARACTER_IGUAL:
	inc si //avanca na memoria STRING1
	inc di //avanca na memoria STRING2
	jmp COMPARA_STRING_CONTINUA_COMPARACAO
COMPARA_STRING_STRING1_FINAL:
	cmp dh, NULL
	je COMPARA_STRING_IGUAIS
	mov al, false
	jmp COMPARA_STRING_SAI	
COMPARA_STRING_STRING2_FINAL:
	cmp dl, NULL 
	je COMPARA_STRING_IGUAIS
	mov al, false
	jmp COMPARA_STRING_SAI 
COMPARA_STRING_IGUAIS:
	mov al, true //sinaliza em AL que sao iguais	
COMPARA_STRING_SAI:
	pop dx
	popf
      }
}

//nao esquecer de inicializar bx com o endereco da variavel STRINGx
void RECEBER_STRING(void)
{
   _asm
   {
      pushf
      push ax
      mov QNT_CARACTERES_DIGITADOS,0
RECEBER_STRING_CARACTER:      
      call RECEBER_CARACTER // al = ascii da tecla pressionada
      cmp al, 13 //CR
      je   RECEBER_CARACTER_TRATA_CR
      cmp al, 8 //BS
      je   RECEBER_CARACTER_TRATA_BS	
      cmp QNT_CARACTERES_DIGITADOS,TAM //atingiu limite ????
      je  RECEBER_STRING_CARACTER //ignora armazenamento da tecla      
      mov  [bx], al //armazena em STRING na posicao bx
      inc  bx //avanca bx
      inc QNT_CARACTERES_DIGITADOS
      call MANDA_CARACTER // manda para terminal burro
      jmp  RECEBER_STRING_CARACTER            
RECEBER_CARACTER_TRATA_CR:      
      mov al,0 //NULL
      mov [bx], al
      jmp RECEBER_STRING_SAI
RECEBER_CARACTER_TRATA_BS:      
      cmp QNT_CARACTERES_DIGITADOS,0
      je  RECEBER_STRING_CARACTER
      dec bx //ou sub bx,1
      dec QNT_CARACTERES_DIGITADOS
      mov al, 8 //BS
      call MANDA_CARACTER //manda backspace para o TERMINAL
      jmp RECEBER_STRING_CARACTER
RECEBER_STRING_SAI:            
      pop ax
      popf
   }
}

// BX deve apontar para STRING a ser impressa no TERMINAL
void MANDA_STRING(void)
{
   _asm
   {
     pushf
     push ax
MANDA_STRING_PROCURA_NULL:      
     mov al, [bx]   
     cmp al, 0 //cheguei em NULL
     je MANDA_STRING_SAI
     call MANDA_CARACTER
     inc bx
     jmp MANDA_STRING_PROCURA_NULL
MANDA_STRING_SAI:      
     pop ax
     popf
   }
} 

//ao finalizar este subprograma, devemos ter em AL o byte digitado
void RECEBER_NUMERO(void)
{
   _asm
   {
      pushf
      push bx
      push cx
      lea bx, STRING //parametro
      mov QNT_CARACTERES_DIGITADOS,0
RECEBER_STRING_CARACTER_NUMERO:      
      call RECEBER_CARACTER // al = ascii da tecla pressionada
      cmp al, 13 //CR
      je   RECEBER_CARACTER_TRATA_CR_NUMERO
      cmp al, 8 //BS
      je   RECEBER_CARACTER_TRATA_BS_NUMERO	
      cmp QNT_CARACTERES_DIGITADOS,TAM_NUMERO //atingiu limite ????
      je  RECEBER_STRING_CARACTER_NUMERO //ignora armazenamento da tecla      
      cmp al,'0'
      jl  RECEBER_STRING_CARACTER_NUMERO //l less
      cmp al,'9'
      jg  RECEBER_STRING_CARACTER_NUMERO //g greater      
      mov  [bx], al //armazena em STRING na posicao bx
      inc  bx //avanca bx
      inc QNT_CARACTERES_DIGITADOS
      call MANDA_CARACTER // manda para terminal burro
      jmp  RECEBER_STRING_CARACTER_NUMERO            
RECEBER_CARACTER_TRATA_CR_NUMERO: 
      cmp QNT_CARACTERES_DIGITADOS,2 //voce digitou 2 caracteres ? 
      jl  RECEBER_STRING_CARACTER_NUMERO
      mov al,0 //NULL
      mov [bx], al
      jmp RECEBER_STRING_SAI_NUMERO
RECEBER_CARACTER_TRATA_BS_NUMERO:      
      cmp QNT_CARACTERES_DIGITADOS,0
      je  RECEBER_STRING_CARACTER_NUMERO
      dec bx //ou sub bx,1
      dec QNT_CARACTERES_DIGITADOS
      mov al, 8 //BS
      call MANDA_CARACTER //manda backspace para o TERMINAL
      jmp RECEBER_STRING_CARACTER_NUMERO
RECEBER_STRING_SAI_NUMERO:
      lea bx, STRING
      mov ch, [bx] // "1"-->1   cx <--- ch,cl
      inc bx
      mov cl, [bx] // "7"-->7
      sub ch, '0' // "1" - 48 = 1
      sub cl, '0' // "7" - 48 = 7
      // mul
      // ax = al * xx
      mov ah, 10  //multiplicador
      mov al, ch
      mul ah  // ax <==== al * ah // neste caso, ax terá 10 
      add al, cl //veja, temos em AL o byte!!!!!!!      
      pop cx
      pop bx
      popf
   }  
}

//certificar que AL tenha o numero a ser impresso
//AL = 17
void MANDAR_NUMERO(void)
{
 _asm
 {
      pushf
      push ax //pq estas salvando al, se al é parametro ? na verdade estou salvando ah
      push bx
      //DIV 
      //DIV XX
      //AX <= AX / XX ---> RESTO --> AH       QUOCIENTE ----> AL
      mov ah, 0
      mov bh, 10
      div bh
      // AX / bh ===> teremos em AH = 7 e em AL = 1
      add al,'0' // 1 ---> "1"
      call MANDA_CARACTER
      add ah,'0' // 7 ---> "7"
      mov al,ah // move "7" para Al para ser impresso!!!!!!!!!!!!!
      call MANDA_CARACTER
      pop bx
      pop ax
      popf
 }  
}


//certificar que AL tenha o numero a ser impresso
//AL = 17
void MANDAR_NUMERO_LCD(void)
{
 _asm
 {
      pushf
      push ax //pq estas salvando al, se al é parametro ? na verdade estou salvando ah
      push bx
      //DIV 
      //DIV XX
      //AX <= AX / XX ---> RESTO --> AH       QUOCIENTE ----> AL
      mov ah, 0
      mov bh, 10
      div bh
      // AX / bh ===> teremos em AH = 7 e em AL = 1
      add al,'0' // 1 ---> "1"
      call PRINT_CAR
      add ah,'0' // 7 ---> "7"
      mov al,ah // move "7" para Al para ser impresso!!!!!!!!!!!!!
      call PRINT_CAR
      pop bx
      pop ax
      popf
 }  
}

void MANDAR_NUMERO_LCD_PREVIEW(void)
{
 _asm
 {
      pushf
      push ax //pq estas salvando al, se al é parametro ? na verdade estou salvando ah
      push bx
      //DIV 
      //DIV XX
      //AX <= AX / XX ---> RESTO --> AH       QUOCIENTE ----> AL
      mov ah, 0
      // AX / bh ===> teremos em AH = 7 e em AL = 1
      add al,'0' // 1 ---> "1"
      call PRINT_CAR
      add ah,'0' // 7 ---> "7"
      mov al,ah // move "7" para Al para ser impresso!!!!!!!!!!!!!
      pop bx
      pop ax
      popf
 }  
}



void PULA_LINHA(void)
{
   _asm 
   {
	 pushf
	 push ax
	 mov al, 13 //cr
	 call MANDA_CARACTER
	 mov al, 10 //lf
	 call MANDA_CARACTER
	 pop ax
	 popf
   }
}
 
//19200,8,N,1
void INICIALIZA_8251(void)
{
   _asm {
   MOV AL,0
   MOV DX, ADR_USART_CMD
   OUT DX,AL
   OUT DX,AL
   OUT DX,AL
   MOV AL,40H
   OUT DX,AL
   MOV AL,4DH
   OUT DX,AL
   MOV AL,37H
   OUT DX,AL
      }
}

//TENHA CERTEZA QUE O CARACTER ESTEJA EM AL
//AL É A PASSAGEM DE PARAMETRO - (POR REGISTRADOR)
void MANDA_CARACTER(void)
{
   _asm {
      PUSHF  ; SALVA FLAGS Z E C
      PUSH DX
      PUSH AX  ; SALVA AL   AX = AH/AL
BUSY:
      MOV DX, ADR_USART_STAT
      IN  AL,DX
      TEST AL,1 ; 0000000S
      JZ BUSY
      MOV DX, ADR_USART_DATA
      POP AX  ; RESTAURA AL
      OUT DX,AL
      POP DX
      POPF ; RESTAURA FLAGS Z E C
   }  
}

//AO TERMINO DESTA ROTINA, TEREMOS EM AL
//O CODIGO ASCII DA TECLA DIGITADA
void RECEBER_CARACTER(void)
{
   _asm {
      PUSHF
      PUSH DX
AGUARDA_CARACTER:
      MOV DX, ADR_USART_STAT
      IN  AL,DX
      TEST AL,2 ;000000S0
      JZ AGUARDA_CARACTER
      MOV DX, ADR_USART_DATA
      IN AL,DX
      SHR AL,1 
NAO_RECEBIDO:
      POP DX
      POPF
   }
}

//SE O PROGRAMA CHEGOU ATÉ AQUI, FOI POR INTERRUPCAO DA CONTROLADORA DO TECLADO
//BASTA ENTAO APENAS LER!!!!
void RECEBER_CARACTER_INT(void)
{
   _asm {
      PUSHF
      PUSH DX
      MOV DX, ADR_USART_DATA
      IN AL,DX
      SHR AL,1 
      POP DX
      POPF
   }
}

//AO TERMINO DESTA ROTINA, TEREMOS EM AL NULL SE NADA FOI DIGITADO
//CASO CONTRARIO, AL TEM O Q FOI DIGITADO
void RECEBER_CARACTER_NO_BLOCKING(void)
{
   _asm {
      PUSHF
      PUSH DX
AGUARDA_CARACTER:
      MOV DX, ADR_USART_STAT
      IN  AL,DX
      TEST AL,2 ;000000S0
      JZ RECEBER_CARACTER_NO_BLOCKING_NADA_DIGITADO
      MOV DX, ADR_USART_DATA
      IN AL,DX
      SHR AL,1 
      JMP RECEBER_CARACTER_NO_BLOCKING_SAI
RECEBER_CARACTER_NO_BLOCKING_NADA_DIGITADO: 
      MOV AL, NULL      
RECEBER_CARACTER_NO_BLOCKING_SAI:
      POP DX
      POPF
   }
}

//esta não será chamada mais por vc
//mas sim pelo tratador de interrupcao
void RECEBER_CARACTER_INTERRUPT(void)
{
   _asm {
      PUSHF
      PUSH DX
      MOV DX, ADR_USART_DATA
      IN AL,DX
      SHR AL,1 
      POP DX
      POPF
   }
}

void Testa_74154(void)
{
   _asm
   {
      mov dx, IO0  //o endereco da controladora deve estar em dx (16 bits)
      out dx, al //dado a ser escrito na controladora deve estar em Al (8 bits)
      mov dx, IO1  //o endereco da controladora deve estar em dx (16 bits)
      out dx, al //dado a ser escrito na controladora deve estar em Al (8 bits)
      mov dx, IO2  //o endereco da controladora deve estar em dx (16 bits)
      out dx, al //dado a ser escrito na controladora deve estar em Al (8 bits)
      mov dx, IO3  //o endereco da controladora deve estar em dx (16 bits)
      out dx, al //dado a ser escrito na controladora deve estar em Al (8 bits)
      mov dx, IO4  //o endereco da controladora deve estar em dx (16 bits)
      out dx, al //dado a ser escrito na controladora deve estar em Al (8 bits)
      mov dx, IO5  //o endereco da controladora deve estar em dx (16 bits)
      out dx, al //dado a ser escrito na controladora deve estar em Al (8 bits)
   }
}

void Testa_Controladora_Leds(void)
{
      _asm
   {
      mov dx, IO0 
      mov al, 0b00000001
      out dx, al
      mov al, 0b00000010
      out dx, al
   }
}

void Le_Escreve(void)
{
 _asm 
   {
      mov dx, IO2  ; faz a leitura do teclado
      in  al, dx   ; al = xxxxxxxx
      mov dx, IO0
      out dx, al   ; manda dado lido para controladora IO0
      mov dx, IO1
      out dx, al   ; manda dado lido para controladora IO0
   }
}

//1s
void Pausa(void)
{
   //esta Rotina será transformada em Assembly e fará uso de registradores
   unsigned int Cont = 65535;
   while(Cont--)
   {
   }
}

void Erro_Porta(void)
{
   _asm
   {
      mov dx, IO2  ; le sensores
      in  al, dx   ; 0000PCME
		   ; 00001000
                   ;---------- AND
		   ; 00001000  al
      and al, 0b00001000
      cmp al, 0b00001000
      je  Porta_ok
      
      mov dx, IO1 ; display de 7 segmentos
      mov al, 0b11110011 ; escreve P no display de 7 segmentos
      out dx, al
      call Pausa
    
      mov al, 0b00000000;  apaga display 7 segmentos
      out dx, al
      call Pausa
      
Porta_ok:      
   }
}

void Erro_Cinto(void)
{
   _asm
   {
      mov dx, IO2  ; le sensores
      in  al, dx   ; 0000PCME
		   ; 00000100
                   ;---------- AND
		   ; 00000100  al
      and al, 0b00000100
      cmp al, 0b00000100
      je  Cinto_ok
      
      mov dx, IO1 ; display de 7 segmentos
      ;          GFEDCBA    
      mov al, 0b10111001 ; escreve C no display de 7 segmentos
      out dx, al
      call Pausa
    
      mov al, 0b00000000;  apaga display 7 segmentos
      out dx, al
      call Pausa
      
Cinto_ok:      
   }
}

void Erro_Marcha_Embreagem(void)
{
   _asm
   {
      mov dx, IO2  ; le sensores
      in  al, dx   ; 0000PCME
		   ; 00000011
                   ;---------- AND
		   ; 000000ME  al
      and al, 0b00000011
      cmp al, 0b00000010
      jne  Marcha_Embreagem_ok ; jmp if not equal
      
      mov dx, IO1 ; display de 7 segmentos
      ;          GFEDCBA
      mov al, 0b10110111 ; escreve M no display de 7 segmentos
      out dx, al
      call Pausa
    
      mov al, 0b0000000;  apaga display 7 segmentos
      out dx, al
      call Pausa
      ;          GFEDCBA    
      mov al, 0b11111001 ; escreve E no display de 7 segmentos
      out dx, al
      call Pausa
      
      mov al, 0b00000000;  apaga display 7 segmentos
      out dx, al
      call Pausa
       
Marcha_Embreagem_ok:      
   }
}



void Manda_Codigo_Erro(void)
{
   _asm
   {
	 call Erro_Porta
	 call Erro_Cinto
	 call Erro_Marcha_Embreagem
   }
}

void Board_Computer(void)
{
   _asm 
   {
      mov dx, IO2 ; le sensores do computador de bordo
      in  al, dx  ; al = 0000PCME
      cmp al, 0b00001100 ; compare
      je  habilita_ignicao ; jmp if equal
      cmp al, 0b00001101
      je  habilita_ignicao ; jmp if equal
      cmp al, 0b00001111
      je  habilita_ignicao ; jmp if equal
      ; aqui deves desabilitar a ignicao <===
      
      mov dx, IO0
      mov al, 0b00000000 ; desligue todos os leds para sinalizar ignicao desabilitada
      out dx, al   
      call Manda_Codigo_Erro
      
      jmp saida_ignicao
     
habilita_ignicao:
      mov dx, IO0
      mov al, 0b11111111 ; ligue todos os leds para sinalizar ignicao habilitada
      out dx, al

saida_ignicao:
      
   }   
}


//esta rotina espera que o reg AL
//tenha o valor binario!
void Conv_Bin_Dec(void)
{
   _asm
   {
      cmp al,0
      je converte_0
      cmp al,1
      je converte_1
      cmp al,2
      je converte_2
      cmp al,3
      je converte_3
      cmp al,4
      je converte_4
      cmp al,5
      je converte_5
      cmp al,6
      je converte_6
      cmp al,7
      je converte_7
      cmp al,8
      je converte_8
      cmp al,9
      je converte_9
	    ;   GFEDCBA
      mov al,0b01111001 ; codigo de erro "E"
      jmp sai_converte_bin_dec

converte_0:
	    ;   GFEDCBA
      mov al,0b00111111
      jmp sai_converte_bin_dec
converte_1:
	    ;   GFEDCBA
      mov al,0b00000110
      jmp sai_converte_bin_dec
converte_2:
	    ;   GFEDCBA
      mov al,0b01011011
      jmp sai_converte_bin_dec
converte_3:
	    ;   GFEDCBA
      mov al,0b01001111
      jmp sai_converte_bin_dec
converte_4:
	    ;   GFEDCBA
      mov al,0b01100110
      jmp sai_converte_bin_dec
converte_5:
	    ;   GFEDCBA
      mov al,0b01101101
      jmp sai_converte_bin_dec
converte_6:
	    ;   GFEDCBA
      mov al,0b01111101
      jmp sai_converte_bin_dec
converte_7:
	    ;   GFEDCBA
      mov al,0b00000111
      jmp sai_converte_bin_dec
converte_8:
	    ;   GFEDCBA
      mov al,0b01111111
      jmp sai_converte_bin_dec
converte_9:
	    ;   GFEDCBA
      mov al,0b01100111
      jmp sai_converte_bin_dec

sai_converte_bin_dec:

}
}

void Mostra_Horario(void)
{
   _asm
   {
	 mov al, DDH
      	 call Conv_Bin_Dec
	 mov dx, IO3
	 out dx, al
      
	 mov al, UUH
      	 call Conv_Bin_Dec
	 mov dx, IO4
	 out dx, al
      
      	 mov al, DDM
      	 call Conv_Bin_Dec
	 mov dx, IO5
	 out dx, al
      
      	 mov al, UUM
      	 call Conv_Bin_Dec
	 mov dx, IO6
	 out dx, al

      	 mov al, DDS
 	 call Conv_Bin_Dec
	 mov dx, IO7
	 out dx, al

 	 mov al, UUS
	 call Conv_Bin_Dec
	 mov dx, IO8
	 out dx, al
   }
   
}

void Atualiza_Horario(void)
{
   _asm  
   {
     inc UUS
     cmp UUS,10
     je  inc_DDS
     jmp sai_Atualiza_Horario
      
inc_DDS:      
     mov UUS,0
     inc DDS
     cmp DDS,6
     je  inc_UUM 
     jmp sai_Atualiza_Horario
      
inc_UUM:      
    mov DDS,0
    inc UUM
    cmp UUM,10
    je  inc_DDM
    jmp sai_Atualiza_Horario      
      
inc_DDM:
    mov UUM,0
    inc DDM
    cmp DDM,6
    je inc_UUH
    jmp sai_Atualiza_Horario

inc_UUH:
    mov DDM,0
    inc UUH
    cmp UUH,4
    je  verifica_DDH_vale_2
    cmp UUH,10
    je  inc_DDH
    jmp sai_Atualiza_Horario

inc_DDH:
    mov UUH,0
    inc DDH
    
verifica_DDH_vale_2:
    cmp DDH,2
    je  apaga_DDH_UUH
    jmp sai_Atualiza_Horario

apaga_DDH_UUH:
    mov DDH,0
    mov UUH,0
    
sai_Atualiza_Horario:
      
   }
}

void Atualiza_Horario_LCD(void)
{
   _asm  
   {
     inc SSS
     cmp SSS,60
     je  inc_MMM
     jmp sai_Atualiza_Horario_LCD
inc_MMM:
     mov SSS,0
     inc MMM
     cmp MMM,60
     je  inc_HHH
     jmp sai_Atualiza_Horario_LCD
inc_HHH:      
    mov MMM,0
    inc HHH
    cmp HHH,24
    je  zera_HHH
    jmp sai_Atualiza_Horario_LCD      
zera_HHH:
    mov HHH,0
sai_Atualiza_Horario_LCD:
   }
}


void Controla_Leds(void)
{
      _asm
      {
	 cmp al, '0'
	 je  apagar_leds_io0
	 cmp al, '1'
	 je  acender_leds_io0
	 jmp Sai_Controla_Leds 
apagar_leds_io0:
	 mov dx, IO0
	 mov al, 0b00000000
	 out dx, al
	 
	 mov al, 0
	 call Conv_Bin_Dec;
	 mov dx, IO3
	 out dx, al
	 mov dx, IO4
	 out dx, al
	 mov dx, IO5
	 out dx, al
	 mov dx, IO6
	 out dx, al
	 mov dx, IO7
	 out dx, al
	 mov dx, IO8
	 out dx, al
	 	 
	 jmp Sai_Controla_Leds
acender_leds_io0:	 
	 mov dx, IO0
	 mov al, 0b11111111
	 out dx, al	 
	 
 	 mov al, 1
	 call Conv_Bin_Dec;
	 mov dx, IO3
	 out dx, al
	 mov dx, IO4
	 out dx, al
	 mov dx, IO5
	 out dx, al
	 mov dx, IO6
	 out dx, al
	 mov dx, IO7
	 out dx, al
	 mov dx, IO8
	 out dx, al
	 
Sai_Controla_Leds:
      }
}

void Espera_Soltar_Tecla(void)
{
      _asm
      {
	 pushf
	 push ax
	 Espera_Soltar_Tecla_Aguardando:
	    call LE_PORT_C
	    cmp al, 0b1111
	    je  Espera_Soltar_Tecla_Sai
	    jmp Espera_Soltar_Tecla_Aguardando
Espera_Soltar_Tecla_Sai:	 
	 pop ax
	 popf
      }
      
}


void SELECIONA_L1(void)
{
      _asm
   {
      pushf
      push ax
      mov al,0b00001110
      call MANDA_PORT_A
      call LE_PORT_C
      cmp al,0b0111  //c1 = 0
      je  SELECIONA_L1_DIGITOU_7
      cmp al,0b1011  //c2 = 0
      je  SELECIONA_L1_DIGITOU_8
      cmp al,0b1101  //c3 = 0
      je  SELECIONA_L1_DIGITOU_9
      cmp al,0b1110  //c4 = 0
      je  SELECIONA_L1_DIGITOU_DIV
      mov TECLA, NULL
      jmp SELECIONA_L1_SAI
SELECIONA_L1_DIGITOU_7:
      mov TECLA,'7'
      call Espera_Soltar_Tecla
      jmp SELECIONA_L1_SAI
SELECIONA_L1_DIGITOU_8:
      mov TECLA,'8'
      call Espera_Soltar_Tecla
      jmp SELECIONA_L1_SAI
SELECIONA_L1_DIGITOU_9:
      mov TECLA,'9'
      call Espera_Soltar_Tecla
      jmp SELECIONA_L1_SAI
SELECIONA_L1_DIGITOU_DIV:      
      mov TECLA,'/'
      call Espera_Soltar_Tecla
      jmp SELECIONA_L1_SAI
SELECIONA_L1_SAI:      
      pop ax
      popf
   }
}

void SELECIONA_L2(void)
{
      _asm
   {
      pushf
      push ax
      mov al,0b00001101
      call MANDA_PORT_A
      call LE_PORT_C
      cmp al,0b0111  //c1 = 0
      je  SELECIONA_L2_DIGITOU_4
      cmp al,0b1011  //c2 = 0
      je  SELECIONA_L2_DIGITOU_5
      cmp al,0b1101  //c3 = 0
      je  SELECIONA_L2_DIGITOU_6
      cmp al,0b1110  //c4 = 0
      je  SELECIONA_L2_DIGITOU_MUL
      mov TECLA, NULL
      jmp SELECIONA_L2_SAI
SELECIONA_L2_DIGITOU_4:
      mov TECLA,'4'
      call Espera_Soltar_Tecla
      jmp SELECIONA_L2_SAI
SELECIONA_L2_DIGITOU_5:
      mov TECLA,'5'
      call Espera_Soltar_Tecla
      jmp SELECIONA_L2_SAI
SELECIONA_L2_DIGITOU_6:
      mov TECLA,'6'
      call Espera_Soltar_Tecla
      jmp SELECIONA_L2_SAI
SELECIONA_L2_DIGITOU_MUL:      
      mov TECLA,'*'
      call Espera_Soltar_Tecla
      jmp SELECIONA_L2_SAI
SELECIONA_L2_SAI:      
      pop ax
      popf
   }
}

void SELECIONA_L3(void)
{
      _asm
   {
      pushf
      push ax
      mov al,0b00001011
      call MANDA_PORT_A
      call LE_PORT_C
      cmp al,0b0111  //c1 = 0
      je  SELECIONA_L3_DIGITOU_1
      cmp al,0b1011  //c2 = 0
      je  SELECIONA_L3_DIGITOU_2
      cmp al,0b1101  //c3 = 0
      je  SELECIONA_L3_DIGITOU_3
      cmp al,0b1110  //c4 = 0
      je  SELECIONA_L3_DIGITOU_MEN
      mov TECLA, NULL
      jmp SELECIONA_L3_SAI
SELECIONA_L3_DIGITOU_1:
      mov TECLA,'1'
      call Espera_Soltar_Tecla
      jmp SELECIONA_L3_SAI
SELECIONA_L3_DIGITOU_2:
      mov TECLA,'2'
      call Espera_Soltar_Tecla
      jmp SELECIONA_L3_SAI
SELECIONA_L3_DIGITOU_3:
      mov TECLA,'3'
      call Espera_Soltar_Tecla
      jmp SELECIONA_L3_SAI
SELECIONA_L3_DIGITOU_MEN:      
      mov TECLA,'-'
      call Espera_Soltar_Tecla
      jmp SELECIONA_L3_SAI
SELECIONA_L3_SAI:      
      pop ax
      popf
   }
}

void SELECIONA_L4(void)
{
      _asm
   {
      pushf
      push ax
      mov al,0b00000111
      call MANDA_PORT_A
      call LE_PORT_C
      cmp al,0b0111  //c1 = 0
      je  SELECIONA_L4_DIGITOU_C
      cmp al,0b1011  //c2 = 0z
      je  SELECIONA_L4_DIGITOU_0
      cmp al,0b1101  //c3 = 0
      je  SELECIONA_L4_DIGITOU_IGUAL
      cmp al,0b1110  //c4 = 0
      je  SELECIONA_L4_DIGITOU_MAI
      mov TECLA, NULL
      jmp SELECIONA_L4_SAI
SELECIONA_L4_DIGITOU_C:
      mov TECLA,'C'
      call Espera_Soltar_Tecla
      jmp SELECIONA_L4_SAI
SELECIONA_L4_DIGITOU_0:
      mov TECLA,'0'
      call Espera_Soltar_Tecla
      jmp SELECIONA_L4_SAI
SELECIONA_L4_DIGITOU_IGUAL:
      mov TECLA,'='
      call Espera_Soltar_Tecla
      jmp SELECIONA_L4_SAI
SELECIONA_L4_DIGITOU_MAI:      
      mov TECLA,'+'
      call Espera_Soltar_Tecla
      jmp SELECIONA_L4_SAI
SELECIONA_L4_SAI:      
      pop ax
      popf
   }
}

void LE_TECLADO(void)
{
   SELECIONA_L1();
   _asm cmp TECLA,NULL
   _asm jne LE_TECLADO_SAI
   SELECIONA_L2();
   _asm cmp TECLA,NULL
   _asm jne LE_TECLADO_SAI   
   SELECIONA_L3();
   _asm cmp TECLA,NULL
   _asm jne LE_TECLADO_SAI   
   SELECIONA_L4();
   _asm cmp TECLA,NULL
   _asm jne LE_TECLADO_SAI
LE_TECLADO_SAI:
   _asm inc SEED
}

unsigned char LIGA = 1;



/* NMI Interrupt Handler */
// Dicas
// Seja o mais breve possivel na execucao!
void _interrupt _far nmi_handler(void)
{
   /*
   _asm
   {
      cmp LIGA,1
      je LIGA_8253
      mov bx, 0
      call INICIALIZA_8253_TIMER0
      mov LIGA,1
      jmp sai_interrupt
LIGA_8253:
      mov bx, 100000 / 52 
      call INICIALIZA_8253_TIMER0
      mov LIGA,0
sai_interrupt: 
     NOP  
   }
   */
}

void _interrupt _far int0_handler(void)
{  
}

void _interrupt _far int1_handler(void)
{  

}

void _interrupt _far int2_handler(void)
{  

}

void _interrupt _far int3_handler(void)
{  
}

void _interrupt _far int4_handler(void)
{  
}

void _interrupt _far int5_handler(void)
{  
}

void _interrupt _far int6_handler(void)
{  
}

void _interrupt _far int7_handler(void)
{  
}

//ESTA ROTINA ALTERA O VETOR DE INTERRUPCAO INT_NO PARA QUE APONTE PARA SERVICE_PROC
void set_int(unsigned char int_no, void * service_proc)
 { _asm
    { push es
      xor ax, ax  //zera ax
      mov es, ax  // manda ES aponta para SEGMENTO 0
      mov al, int_no //pega no numero da interrupcao 2
      xor ah, ah     //zera ah //ax 0000000000000010
      shl ax, 1      //shift left rotaciona esquerda 0000000000000010
                                                   //0000000000000100
                                                   //0000000000001000       
      shl ax, 1      //shift left rotaciona esquerda
      mov si, ax  //manda si apontar para endereco 8
      mov ax, service_proc //pega o endereco da tratadora
      mov es:[si], ax //escreve na memoria a partir de 8 
      inc si //
      inc si //
      mov bx, cs //segmento onde esta a tua rotina tratadora, seg 0 (Code Segmento)
      mov es:[si], bx //escreve segmento
      pop es  //gravamos entao em 8,9,10,11 o endereco do tratador e o segmento onde ele se encontra
    }
 }

 //ROTINA 8253
//O DIVISOR DEVE ESTAR EM BX
//ANTES DE CHAMAR A ROTINA ABAIXO
void INICIALIZA_8253_TIMER0(void)
{
   _asm {
    PUSHF
   PUSH AX
   PUSH DX
   
   MOV AL,36H
   MOV DX, ADR_TIMER_CONTROL
   OUT DX,AL

   MOV AL,BL //BX
   MOV DX, ADR_TIMER_DATA0
   OUT DX,AL

   MOV AL,BH //BX
   MOV DX, ADR_TIMER_DATA0
   OUT DX,AL
   
   POP DX
   POP AX
   POPF
   }
}

void INICIALIZA_8259(void)
{
   _asm
   {
      pushf
      push ax
      push dx
      mov dx, IO13 //1A00
      mov al, 13H
      out dx, al
      mov dx, IO13 + 2 //1A02
      mov al, 70h
      out dx, al
      mov al, 1bh
      out dx, al
      mov al, 00h
      out dx, al
      pop dx
      pop ax
      popf
    }
}

void ALTERANDO_RELOGIO(void) {
      RESETA_VARIAVEIS_HORAS();
      LIMPA_TELA_LCD();
      _asm MOV AH,0
      _asm MOV AL,0
      GLCD_GOTO_XY_TEXT(); 
      _asm lea si, RELOGIO
      PRINT_ICON();
      _asm mov di, 0
      while(true) {
      _asm cmp di, 6
      _asm je SAIR_LEITURA_TECLADO_INICIAL
      LE_TECLADO();  //ao chamar LE_TECLADO, terei na variavel TECLA: NULL ou ASCII
      _asm cmp TECLA, NULL
      _asm je NAO_IMPRIMIR
      _asm mov al, TECLA
      _asm {
	 sub al, '0'
	 cmp di, 0
	 je DEFINE_DEZENA_HORA
	 
	 cmp di, 1
	 je DEFINE_UNIDADE_HORA
	 
	 cmp di, 2
	 je DEFINE_DEZENA_MINUTO
	 
	 cmp di, 3
	 je DEFINE_UNIDADE_MINUTO
	 
	 cmp di, 4
	 je DEFINE_DEZENA_SEGUNDO
	 
	 cmp di, 5
	 je DEFINE_UNIDADE_SEGUNDO
	 
	 jmp DEFINE_SAIR
	 
	 DEFINE_DEZENA_HORA:
	    mov dezena_hora, al
	    _asm MOV AH,4
	    _asm MOV AL,3
	    call GLCD_GOTO_XY_TEXT
	    mov al, dezena_hora
	    call MANDAR_NUMERO_LCD_PREVIEW
	    jmp DEFINE_SAIR
	 
	 DEFINE_UNIDADE_HORA:
	    mov unidade_hora, al
	    _asm MOV AH,5
	    _asm MOV AL,3
	    call GLCD_GOTO_XY_TEXT
	    mov al, unidade_hora
	    call MANDAR_NUMERO_LCD_PREVIEW
	    _asm MOV AH,6
	    _asm MOV AL,3
	    call GLCD_GOTO_XY_TEXT
	    mov al, ':'
	    call PRINT_CAR
	    jmp DEFINE_SAIR
	 
	 DEFINE_DEZENA_MINUTO:
	    mov dezena_minuto, al
	    _asm MOV AH,7
	    _asm MOV AL,3
	    call GLCD_GOTO_XY_TEXT
	    mov al, dezena_minuto
	    call MANDAR_NUMERO_LCD_PREVIEW
	    jmp DEFINE_SAIR
	 
	 DEFINE_UNIDADE_MINUTO:
	    mov unidade_minuto, al
	    _asm MOV AH,8
	    _asm MOV AL,3
	    call GLCD_GOTO_XY_TEXT
	    mov al, unidade_minuto
	    call MANDAR_NUMERO_LCD_PREVIEW
	    _asm MOV AH,9
	    _asm MOV AL,3
	    call GLCD_GOTO_XY_TEXT
	    mov al, ':'
	    call PRINT_CAR
	    jmp DEFINE_SAIR
	 
	 DEFINE_DEZENA_SEGUNDO:
	    mov dezena_segundo, al
	    _asm MOV AH,10
	    _asm MOV AL,3
	    call GLCD_GOTO_XY_TEXT
	    mov al, dezena_segundo
	    call MANDAR_NUMERO_LCD_PREVIEW
	    jmp DEFINE_SAIR
	    
	 DEFINE_UNIDADE_SEGUNDO:
	    mov unidade_segundo, al
	    _asm MOV AH,11
	    _asm MOV AL,3
	    call GLCD_GOTO_XY_TEXT
	    mov al, unidade_segundo
	    call MANDAR_NUMERO_LCD_PREVIEW
	    jmp DEFINE_SAIR
	    
	 DEFINE_SAIR:
      }
      _asm call MANDA_CARACTER
      _asm inc di
      
NAO_IMPRIMIR:
      _asm nop      
   }       
   _asm {
       SAIR_LEITURA_TECLADO_INICIAL:
	 call LIMPA_TELA_LCD
   }

   SSS = dezena_segundo * 10 + unidade_segundo;
   MMM = dezena_minuto * 10 + unidade_minuto;
   HHH = dezena_hora * 10 + unidade_hora;

}

void MOSTRA_RELOGIO_RODANDO(void) {
   _asm MOV AH,0
   _asm MOV AL,0
   GLCD_GOTO_XY_TEXT(); 
   _asm lea si, RELOGIO
   PRINT_ICON();
   
   LE_TECLADO();
   _asm {
      mov al, TECLA
      cmp al, '/'
      je MODO_ALTERA_RELOGIO
      jmp ALTERA_RELOGIO_SAI
   MODO_ALTERA_RELOGIO:
      call ALTERANDO_RELOGIO
      jmp ALTERA_RELOGIO_SAI
   ALTERA_RELOGIO_SAI:
      
   }
   
   _asm MOV AH,3
   _asm MOV AL,3
   GLCD_GOTO_XY_TEXT();    
   _asm mov al, HHH
   MANDAR_NUMERO_LCD();
   _asm MOV AH,5
   _asm MOV AL,3
   GLCD_GOTO_XY_TEXT();    
   _asm mov al, ':'
   PRINT_CAR();
    
   _asm MOV AH,6
   _asm MOV AL,3
   GLCD_GOTO_XY_TEXT();    
   _asm mov al, MMM
   MANDAR_NUMERO_LCD();
   _asm MOV AH,8
   _asm MOV AL,3
   GLCD_GOTO_XY_TEXT();    
   _asm mov al, ':'
   PRINT_CAR();
    
   _asm MOV AH,9
   _asm MOV AL,3
   GLCD_GOTO_XY_TEXT();    
   _asm mov al, SSS
   MANDAR_NUMERO_LCD();
   
}

void RESETA_TEMPO_DESPERTADOR(void) {
   MMM_despertador = 0;
   HHH_despertador = 0;
   despertador_definido = 0;
   
}

void MOSTRA_DESPERTADOR_RODANDO(void) {  
   _asm MOV AH,0
   _asm MOV AL,0
   GLCD_GOTO_XY_TEXT(); 
   _asm lea si, DESPERTADOR
   PRINT_ICON();
   
    LE_TECLADO();  //ao chamar LE_TECLADO, terei na variavel TECLA: NULL ou ASCII
   _asm {
      mov al, TECLA
      cmp al, '*'
      je MODO_ALTERA_DESPERTADOR
      jmp ALTERA_DESPERTADOR_SAI
   MODO_ALTERA_DESPERTADOR:
      call ALTERANDO_DESPERTADOR
      jmp ALTERA_DESPERTADOR_SAI
   ALTERA_DESPERTADOR_SAI:
   }
   
   MOSTRA_DESPERTADOR_VARIAVEIS:
      _asm MOV AH,3
      _asm MOV AL,3
      GLCD_GOTO_XY_TEXT();    
      _asm mov al, HHH_despertador
      MANDAR_NUMERO_LCD();
      _asm MOV AH,5
      _asm MOV AL,3
      GLCD_GOTO_XY_TEXT();    
      _asm mov al, ':'
      PRINT_CAR();
       
      _asm MOV AH,6
      _asm MOV AL,3
      GLCD_GOTO_XY_TEXT();    
      _asm mov al, MMM_despertador
      MANDAR_NUMERO_LCD();
}

void RESETA_VARIAVEIS_HORAS(void) {
   dezena_hora = 0;
   unidade_hora = 0;
   dezena_minuto = 0;
   unidade_minuto = 0;
   dezena_segundo = 0;
   unidade_segundo = 0;
}

void ALTERANDO_DESPERTADOR(void) {
   RESETA_VARIAVEIS_HORAS();
   LIMPA_TELA_LCD();
   _asm MOV AH,0
   _asm MOV AL,0
   GLCD_GOTO_XY_TEXT(); 
   _asm lea si, DESPERTADOR
   PRINT_ICON();
   _asm mov di, 0
  while(true) {   
      _asm cmp di, 4
      _asm je SAIR_LEITURA_TECLADO_INICIAL
      LE_TECLADO();  //ao chamar LE_TECLADO, terei na variavel TECLA: NULL ou ASCII
      _asm cmp TECLA, NULL
      _asm je NAO_IMPRIMIR
      _asm mov al, TECLA
      _asm {
	 sub al, '0'
	 cmp di, 0
	 je DEFINE_DEZENA_HORA
	 
	 cmp di, 1
	 je DEFINE_UNIDADE_HORA
	 
	 cmp di, 2
	 je DEFINE_DEZENA_MINUTO
	 
	 cmp di, 3
	 je DEFINE_UNIDADE_MINUTO
	 
	 jmp DEFINE_SAIR
	 
	 DEFINE_DEZENA_HORA:
	    mov dezena_hora, al
	    _asm MOV AH,4
	    _asm MOV AL,3
	    call GLCD_GOTO_XY_TEXT
	    mov al, dezena_hora
	    call MANDAR_NUMERO_LCD_PREVIEW
	    jmp DEFINE_SAIR
	 
	 DEFINE_UNIDADE_HORA:
	    mov unidade_hora, al
	    _asm MOV AH,5
	    _asm MOV AL,3
	    call GLCD_GOTO_XY_TEXT
	    mov al, unidade_hora
	    call MANDAR_NUMERO_LCD_PREVIEW
	    _asm MOV AH,6
	    _asm MOV AL,3
	    call GLCD_GOTO_XY_TEXT
	    mov al, ':'
	    call PRINT_CAR
	    jmp DEFINE_SAIR
	 
	 DEFINE_DEZENA_MINUTO:
	    mov dezena_minuto, al
	    _asm MOV AH,7
	    _asm MOV AL,3
	    call GLCD_GOTO_XY_TEXT
	    mov al, dezena_minuto
	    call MANDAR_NUMERO_LCD_PREVIEW
	    jmp DEFINE_SAIR
	 
	 DEFINE_UNIDADE_MINUTO:
	    mov unidade_minuto, al
	    _asm MOV AH,8
	    _asm MOV AL,3
	    call GLCD_GOTO_XY_TEXT
	    mov al, unidade_minuto
	    call MANDAR_NUMERO_LCD_PREVIEW
	    jmp DEFINE_SAIR
	     
	 DEFINE_SAIR:
      }
      _asm call MANDA_CARACTER
      _asm inc di
      
NAO_IMPRIMIR:
      _asm nop      
   }       
   _asm {
       SAIR_LEITURA_TECLADO_INICIAL:
	 mov despertador_definido, 1
	 call LIMPA_TELA_LCD
   }
   
   
   MMM_despertador = dezena_minuto * 10 + unidade_minuto;
   HHH_despertador = dezena_hora * 10 + unidade_hora;

}

void LIMPA_TELA_LCD(void)
{
   _asm {
      lea si, LIMPO
      call PRINT_ICON
      
      lea si, LIMPO
      MOV AH,8
      MOV AL,0
      call GLCD_GOTO_XY_TEXT
      call PRINT_ICON
   }}

void FAZ_BEEP(void) {
   _asm
   {
      pushf
      push bx
      push ax
      
      call INICIALIZA_8253_TIMER0
      
      pop bx
      pop ax
      popf
   }
}

void VALIDA_SOM_5_SEGUNDOS(void) {
   _asm {
      mov al, SSS
      cmp al, 5
      jle CHAMA_FAZ_BEEP
      jmp VALIDA_SOM_SAI
      
     CHAMA_FAZ_BEEP:
	 call FAZ_BEEP
	 jmp SAI_DEPOIS_TOCAR_SOM
      
     VALIDA_SOM_SAI:
	 mov bx, -1
	 call INICIALIZA_8253_TIMER0
      
     SAI_DEPOIS_TOCAR_SOM:
   }
}

void VALIDA_DESPERTADOR_UNIDADE(void) {
   _asm {
      mov ah, MMM
      mov al, MMM_despertador
      cmp al, ah
      je VALIDA_HORAS
      jmp VALIDA_DESPERTADOR_SAI
      
   VALIDA_HORAS:
      mov ah, HHH
      mov al, HHH_despertador
      cmp al, ah
      je CHAMA_FAZ_BEEP
      jmp VALIDA_DESPERTADOR_SAI
      
   CHAMA_FAZ_BEEP:
      call VALIDA_SOM_5_SEGUNDOS
      jmp SAI_DEPOIS_DO_BEEP
   VALIDA_DESPERTADOR_SAI:
      
   SAI_DEPOIS_DO_BEEP:
   }
}



//retorna em AL o random
void RANDOM(void)
{
   _asm {
        PUSH DX
	MOV AX,SEED ;; AX = seed
	MOV DX,8405h ;; DX = 8405h
	MUL DX ;; MUL (8405h * SEED) into dword DX:AX
	CMP AX,SEED
	JNZ GOTSEED ;; if new SEED = old SEED, alter SEED
	MOV AH,DL
	INC AX
GOTSEED:
	MOV SEED,AX ;; We have a new seed, so store it
	MOV AX,DX ;; 
	POP DX
       }
}

void Preenche_Random_Table(void)
{
   _asm
   {
      pushf
      push si
      push ax
      mov si, 0 //indice
Proximo_Preenche_Random_Table:
      call RANDOM //al = 0..255 mask 0000 0011
      and  al,0b00000011
      mov RANDOM_TABLE[si],al
      inc  si //avanca para proximo indice
      cmp  si,1024
      je Sai_Preenche_Random_Table
      jmp Proximo_Preenche_Random_Table
Sai_Preenche_Random_Table:   
      pop ax
      pop si
      popf
   }
}

void IMPRIME_ESQUERDA_BAIXO(void)
{
   _asm MOV AH,4
   _asm MOV AL,4
   GLCD_GOTO_XY_TEXT(); 
   _asm lea si, ESQUERDA_BAIXO
   PRINT_ICON();
}

void IMPRIME_ESQUERDA_CIMA(void)
{
   _asm MOV AH,4
   _asm MOV AL,0
   GLCD_GOTO_XY_TEXT(); 
   _asm lea si, ESQUERDA_CIMA
   PRINT_ICON();
}

void IMPRIME_DIREITA_BAIXO(void)
{
   _asm MOV AH,8
   _asm MOV AL,4
   GLCD_GOTO_XY_TEXT(); 
   _asm lea si, DIREITA_BAIXO
   PRINT_ICON();
}

void IMPRIME_DIREITA_CIMA(void)
{
   _asm MOV AH,8
   _asm MOV AL,0
   GLCD_GOTO_XY_TEXT(); 
   _asm lea si, DIREITA_CIMA
   PRINT_ICON();
}

void IMPRIME_ESQUERDA_BAIXO_BEEP(void)
{
   IMPRIME_ESQUERDA_BAIXO();
   _asm mov bx, 530
   FAZ_BEEP();
}


void IMPRIME_ESQUERDA_CIMA_BEEP(void)
{
   IMPRIME_ESQUERDA_CIMA();
   _asm mov bx, 430
   FAZ_BEEP();
}

void IMPRIME_DIREITA_BAIXO_BEEP(void)
{
   IMPRIME_DIREITA_BAIXO();
   _asm mov bx, 230
   FAZ_BEEP();
}

void IMPRIME_DIREITA_CIMA_BEEP(void)
{
   IMPRIME_DIREITA_CIMA();
   _asm mov bx, 330
   FAZ_BEEP();
}

void MANDAR_NUMERO_LCD_GRANDE(void)
{
 _asm
 {
      pushf
      push ax //pq estas salvando al, se al é parametro ? na verdade estou salvando ah
      push bx
      push cx
      push dx
      //DIV 
      //DIV XX
      //AX <= AX / XX ---> RESTO --> AH       QUOCIENTE ----> AL
      mov ah, 0
      mov bh, 10
      div bh
      mov dh, ah
      mov ah, 0
      div bh
      mov cl, ah
      mov ch, al
    // Os caracteres do número
      add dh, '0' 
      add cl, '0'
      add ch, '0'
      mov al, ch
      call PRINT_CAR
      mov al, cl
      call PRINT_CAR
      mov al, dh
      call PRINT_CAR
      pop dx
      pop cx
      pop bx
      pop ax
      popf
 }  
}

void IMPRIME_SCORE(void)
{
   _asm {
      MOV AH,0
      MOV AL,0
      call GLCD_GOTO_XY_TEXT
      mov al, SCORE
      call MANDAR_NUMERO_LCD_GRANDE
   }
}

void IMPRIME_PREVIEW(void)
{
   _asm {
      MOV AH,0
      MOV AL,0
      call GLCD_GOTO_XY_TEXT
      mov al, 63
      call MANDAR_NUMERO_LCD_GRANDE
   }
}

void PRINTA_LATEST(void)
{
   _asm {
      mov al, RANDOM_TABLE[di]
      cmp al, 0
      je PRINTA_ESQUERDA_CIMA
      cmp al, 1
      je PRINTA_DIREITA_CIMA
      cmp al, 2
      je PRINTA_ESQUERDA_BAIXO
      cmp al, 3
      je PRINTA_DIREITA_BAIXO
	 jmp PRINTA_SAI
      PRINTA_ESQUERDA_CIMA:
	 call IMPRIME_ESQUERDA_CIMA_BEEP
	 jmp PRINTA_SAI
      PRINTA_DIREITA_CIMA:
	 call IMPRIME_DIREITA_CIMA_BEEP
	 jmp PRINTA_SAI
      PRINTA_ESQUERDA_BAIXO:
	 call IMPRIME_ESQUERDA_BAIXO_BEEP
	 jmp PRINTA_SAI
      PRINTA_DIREITA_BAIXO:
	 call IMPRIME_DIREITA_BAIXO_BEEP
	 jmp PRINTA_SAI
      PRINTA_SAI:
	 mov bx, -1
	 call FAZ_BEEP
   }
}

void MOSTRA_TELA_ERRO(void)
{
   LIMPA_TELA_LCD();
   
   _asm MOV AH,4
   _asm MOV AL,0
   GLCD_GOTO_XY_TEXT(); 
   _asm lea si, ERRO_ICON
   PRINT_ICON();
   
   _asm {
      mov bp, 10
      mov si, 10
      delay8:
      dec bp
      nop
      jnz delay8
      dec si
      cmp si,0
      jnz delay8
   }
   
   EXECUTAR_TENTATIVA_JOGO();
}

void VALIDA_ESQUERDO_CIMA(void) 
{
   _asm {
      mov di, CURRENT_ANSWER
      mov al, RANDOM_TABLE[di]
      
      cmp al, 0
      jne ADICIONA_CONTADOR_ERRO_EC
      jmp SAI_VALIDACAO_ESQUERDA_CIMA
      
   ADICIONA_CONTADOR_ERRO_EC:
      call MOSTRA_TELA_ERRO
      jmp SAI_VALIDACAO_ESQUERDA_CIMA
      
   SAI_VALIDACAO_ESQUERDA_CIMA:
      
   }
}

void VALIDA_ESQUERDO_BAIXO(void) 
{
   _asm {
      mov di, CURRENT_ANSWER
      mov al, RANDOM_TABLE[di]
      
      cmp al, 2
      jne ADICIONA_CONTADOR_ERRO_EB
      jmp SAI_VALIDACAO_ESQUERDA_BAIXO
      
   ADICIONA_CONTADOR_ERRO_EB:
      call MOSTRA_TELA_ERRO
      jmp SAI_VALIDACAO_ESQUERDA_BAIXO
      
   SAI_VALIDACAO_ESQUERDA_BAIXO:
      
   }
}

void VALIDA_DIREITA_CIMA(void) 
{
   _asm {
      mov di, CURRENT_ANSWER
      mov al, RANDOM_TABLE[di]
      
      cmp al, 1
      jne ADICIONA_CONTADOR_ERRO_DC
      jmp SAI_VALIDACAO_DIREITA_CIMA
      
   ADICIONA_CONTADOR_ERRO_DC:
      call MOSTRA_TELA_ERRO
      jmp SAI_VALIDACAO_DIREITA_CIMA
      
   SAI_VALIDACAO_DIREITA_CIMA:
      
   }
}

void VALIDA_DIREITA_BAIXO(void) 
{
   _asm {
      mov di, CURRENT_ANSWER
      mov al, RANDOM_TABLE[di]
      
      cmp al, 3
      jne ADICIONA_CONTADOR_ERRO_DB
      jmp SAI_VALIDACAO_DIREITA_BAIXO
      
   ADICIONA_CONTADOR_ERRO_DB:
      call MOSTRA_TELA_ERRO
      jmp SAI_VALIDACAO_DIREITA_BAIXO
      
   SAI_VALIDACAO_DIREITA_BAIXO:
      
   }
}

void INICIA_JOGO(void)
{
   LIMPA_TELA_LCD();
   IMPRIME_SCORE();
   _asm mov di, 0 // indice
   while (true){
      LIMPA_TELA_LCD();
      IMPRIME_SCORE();
      _asm {
	 mov di, SCORE
	 call RANDOM //al = 0..255 mask 0000 0011
	 and  al,0b00000011
	 mov RANDOM_NUMBER, al
	 mov RANDOM_TABLE[di], al
	 
	 // PRINTA LATEST
	 mov al, RANDOM_TABLE[di]
	 cmp al, 0
	 je PRINTA_ESQUERDA_CIMA_A
	 cmp al, 1
	 je PRINTA_DIREITA_CIMA_A
	 cmp al, 2
	 je PRINTA_ESQUERDA_BAIXO_A
	 cmp al, 3
	 je PRINTA_DIREITA_BAIXO_A
	    jmp PRINTA_SAI_A
	 PRINTA_ESQUERDA_CIMA_A:
	    call IMPRIME_ESQUERDA_CIMA_BEEP
	    jmp PRINTA_SAI_A
	 PRINTA_DIREITA_CIMA_A:
	    call IMPRIME_DIREITA_CIMA_BEEP
	    jmp PRINTA_SAI_A
	 PRINTA_ESQUERDA_BAIXO_A:
	    call IMPRIME_ESQUERDA_BAIXO_BEEP
	    jmp PRINTA_SAI_A
	 PRINTA_DIREITA_BAIXO_A:
	    call IMPRIME_DIREITA_BAIXO_BEEP
	    jmp PRINTA_SAI_A
	 PRINTA_SAI_A:

	 
	 inc di
	 mov SCORE, di
      }
      
      
      _asm {
	 mov bp, 10
	 mov si, 10
	 delay8:
	 dec bp
	 nop
	 jnz delay8
	 dec si
	 cmp si,0
	 jnz delay8
      }
      
      _asm {
	 mov bx, -1
	 call FAZ_BEEP
      }
      
      LIMPA_TELA_LCD();
      _asm {
	 mov di, 0
      LOOP_TABLE:
	 mov al, RANDOM_TABLE[di]
	 cmp al, 0
	 je PRINTA_ESQUERDA_CIMA
	 cmp al, 1
	 je PRINTA_DIREITA_CIMA
	 cmp al, 2
	 je PRINTA_ESQUERDA_BAIXO
	 cmp al, 3
	 je PRINTA_DIREITA_BAIXO
	 jmp PRINTA_SAI
      PRINTA_ESQUERDA_CIMA:
	 call IMPRIME_ESQUERDA_CIMA_BEEP
	 jmp PRINTA_SAI
      PRINTA_DIREITA_CIMA:
	 call IMPRIME_DIREITA_CIMA_BEEP
	 jmp PRINTA_SAI
      PRINTA_ESQUERDA_BAIXO:
	 call IMPRIME_ESQUERDA_BAIXO_BEEP
	 jmp PRINTA_SAI
      PRINTA_DIREITA_BAIXO:
	 call IMPRIME_DIREITA_BAIXO_BEEP
	 jmp PRINTA_SAI
      PRINTA_SAI:
	 cmp di, SCORE
	 je LEITURA_TECLADO_ENTRADA
	 inc di
	 
	 mov bp, 10
	 mov si, 10
	 delay9:
	 dec bp
	 nop
	 jnz delay9
	 dec si
	 cmp si,0
	 jnz delay9
	 
	 mov bx, -1
	 call FAZ_BEEP
	 
	 call LIMPA_TELA_LCD
	 jmp LOOP_TABLE
      }
      
      _asm {
	 LEITURA_TECLADO_ENTRADA:
      }
      
      LIMPA_TELA_LCD();

      _asm MOV AH,3
      _asm MOV AL,2
      GLCD_GOTO_XY_TEXT(); 
      _asm lea si, AGUARDANDO_RESPOSTA
      PRINT_ICON();

      CURRENT_ANSWER = 0;
      while (true) {
	 _asm call LE_TECLADO
	 
	 _asm {
	    mov al, TECLA
	    cmp al, '7'
	    je CHAMA_VALIDA_ESQUERDO_CIMA
	    cmp al, '1'
	    je CHAMA_VALIDA_ESQUERDO_BAIXO
	    cmp al, '9'
	    je CHAMA_VALIDA_DIREITA_CIMA
	    cmp al, '3'
	    je CHAMA_VALIDA_DIREITA_BAIXO
	    jmp SAI_LEITURA_TECLADO_RESPOSTA
	    
	    
	 CHAMA_VALIDA_ESQUERDO_CIMA:
	    //inc CURRENT_ANSWER
	    call VALIDA_ESQUERDO_CIMA
	    jmp SAI_LEITURA_TECLADO_INCREMENTANDO
	    
	 CHAMA_VALIDA_ESQUERDO_BAIXO:
	    //inc CURRENT_ANSWER
	    call VALIDA_ESQUERDO_BAIXO
	    jmp SAI_LEITURA_TECLADO_INCREMENTANDO
	    
	 CHAMA_VALIDA_DIREITA_CIMA:
	    //inc CURRENT_ANSWER
	    call VALIDA_DIREITA_CIMA
	    jmp SAI_LEITURA_TECLADO_INCREMENTANDO
	    
	 CHAMA_VALIDA_DIREITA_BAIXO:
	    //inc CURRENT_ANSWER
	    call VALIDA_DIREITA_BAIXO
	    jmp SAI_LEITURA_TECLADO_INCREMENTANDO
	    
	 SAI_LEITURA_TECLADO_INCREMENTANDO:
	    inc CURRENT_ANSWER
	    jmp SAI_LEITURA_TECLADO_RESPOSTA
	    
	 SAI_LEITURA_TECLADO_RESPOSTA:
	    mov al, CURRENT_ANSWER
	    cmp al, SCORE
	    je FINALIZAR_RESPOSTA
	    
	 SAI_ROTINA_WHILE:
	 }
      }
      
      _asm {
      FINALIZAR_RESPOSTA:
	 
      }
   }   
}

void MOSTRA_PAGINA_INICIAL(void)
{
   _asm MOV AH,4
   _asm MOV AL,0
   GLCD_GOTO_XY_TEXT(); 
   _asm lea si, PLAY
   PRINT_ICON();
}

void LIMPA_MEMORIA(void)
{
   SCORE = 0;
   CURRENT_ANSWER = 0;
   
   for (int i = 0; i < 1024; ++i)
    RANDOM_TABLE[i] = 5;
}

void EXECUTAR_TENTATIVA_JOGO(void)
{
   MOSTRA_PAGINA_INICIAL();
   
   LIMPA_MEMORIA();
   
   while (true) {
      _asm call LE_TECLADO
      _asm {
	 mov al, TECLA
	 cmp al, '='
	 je SAI_LEITURA_TECLADO_INICIAL
      }
   }
   _asm {
      SAI_LEITURA_TECLADO_INICIAL:
	 call LIMPA_TELA_LCD
	 call IMPRIME_ESQUERDA_BAIXO
	 call IMPRIME_DIREITA_BAIXO
	 call IMPRIME_ESQUERDA_CIMA
	 call IMPRIME_DIREITA_CIMA
   }
   
   _asm {
      mov bp, 10
      mov si, 10
      delay3:
      dec bp
      nop
      jnz delay3
      dec si
      cmp si,0
      jnz delay3
   }
   
   INICIA_JOGO();
 
}

//funcao principal
void main(void)
 {

   // Write your code here
  //NMI
   set_int(0x02, (void *)&nmi_handler);   //& RETORNA O ENDERECO DA TRATADORA DE INTERRUPCAO    
   set_int(0x70, (void *)&int0_handler);   //& RETORNA O ENDERECO DA TRATADORA DE INTERRUPCAO    
   set_int(0x71, (void *)&int1_handler);   //& RETORNA O ENDERECO DA TRATADORA DE INTERRUPCAO    
   set_int(0x72, (void *)&int2_handler);   //& RETORNA O ENDERECO DA TRATADORA DE INTERRUPCAO    
   set_int(0x73, (void *)&int3_handler);   //& RETORNA O ENDERECO DA TRATADORA DE INTERRUPCAO    
   set_int(0x74, (void *)&int4_handler);   //& RETORNA O ENDERECO DA TRATADORA DE INTERRUPCAO    
   set_int(0x75, (void *)&int5_handler);   //& RETORNA O ENDERECO DA TRATADORA DE INTERRUPCAO    
   set_int(0x76, (void *)&int6_handler);   //& RETORNA O ENDERECO DA TRATADORA DE INTERRUPCAO    
   set_int(0x77, (void *)&int7_handler);   //& RETORNA O ENDERECO DA TRATADORA DE INTERRUPCAO    
   INICIALIZA_8259();
   _asm sti // set interrupt 
   INICIALIZA_8251(); //UMA UNICA VEZ 
   INICIALIZA_8255(); //UMA UNICA VEZ 
   INICIALIZA_8255_LCD(); //UMA UNICA VEZ
   GLCD_ATIVA();
   
   GLCD_CLR();
 
   _asm MOV AH,6
   _asm MOV AL,2
   GLCD_GOTO_XY_TEXT(); 
   _asm lea si, SPLASH
   PRINT_ICON(); 
   _asm {
      mov bp, 10
      mov si, 10
      delay2:
      dec bp
      nop
      jnz delay2
      dec si
      cmp si,0
      jnz delay2
   }
   LIMPA_TELA_LCD();
   
   EXECUTAR_TENTATIVA_JOGO();
}
